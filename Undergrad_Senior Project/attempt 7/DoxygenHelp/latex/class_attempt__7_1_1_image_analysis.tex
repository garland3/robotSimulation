\section{Attempt\_\-7.ImageAnalysis Class Reference}
\label{class_attempt__7_1_1_image_analysis}\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}


It was easier to redure 640$\ast$480 small triangles and view then from a distance than to put a texture on the GPU So there is a camera to view the triangels. The class only analzes a small fraction of the pixels each time through the game loop inorder to keep the speed high. Many of the methods have loops that cause them to only look at every X pixel each time through and then the next time through a different set. Basically it functions like a giant double \char`\"{}for\char`\"{} loop.  




Collaboration diagram for Attempt\_\-7.ImageAnalysis:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=343pt]{class_attempt__7_1_1_image_analysis__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf ImageAnalysis} (Game game, Vector2 screenSize, List$<$ Viewport $>$ viewPortList1)
\begin{DoxyCompactList}\small\item\em Initializes a new instance of the \doxyref{ImageAnalysis}{p.}{class_attempt__7_1_1_image_analysis} class. \item\end{DoxyCompactList}\item 
override void {\bf Initialize} ()
\begin{DoxyCompactList}\small\item\em Called when the class is initialized. Creates many of the arrays and sets many of the values. \item\end{DoxyCompactList}\item 
void {\bf Update1} (GameTime gameTime1)
\begin{DoxyCompactList}\small\item\em Stores the texture from the robot camera in a color array before the texture is disposed. Expicitly called in the \doxyref{SimulationMain}{p.}{class_attempt__7_1_1_simulation_main} Draw method. \item\end{DoxyCompactList}\item 
void {\bf SetRobotCameraView} (Texture2D text)
\begin{DoxyCompactList}\small\item\em Takes a 2D renderTarget/Texture and sets it as the image to analze. Explicitly called in the \doxyref{SimulationMain}{p.}{class_attempt__7_1_1_simulation_main} Draw Method. \item\end{DoxyCompactList}\item 
override void {\bf Update} (GameTime gameTime)
\begin{DoxyCompactList}\small\item\em Calls the analysis methods that actually do all the work. Basically the Main function for the Image Analysis Class. \item\end{DoxyCompactList}\item 
int {\bf GetWhiteCount} ()
\begin{DoxyCompactList}\small\item\em Allows access to the WhiteCount in the image. \item\end{DoxyCompactList}\item 
double[$\,$] {\bf GetHoughInfo} ()
\begin{DoxyCompactList}\small\item\em Gets the houghInfo Array. \item\end{DoxyCompactList}\item 
bool[,] {\bf GetTrueFalseMaptoDraw} ()
\begin{DoxyCompactList}\small\item\em Allows access to the bool map that is to be drawn. \item\end{DoxyCompactList}\item 
string {\bf GetHoughMode} ()
\begin{DoxyCompactList}\small\item\em Gets the Hough mode. 0 = Old, 1 = New. \item\end{DoxyCompactList}\item 
Color[,] {\bf GetColorMapToDraw} ()
\begin{DoxyCompactList}\small\item\em Gets the Color map to be drawn. \item\end{DoxyCompactList}\item 
int {\bf GetTurnIndicator} ()
\begin{DoxyCompactList}\small\item\em Allows the \doxyref{SimulationMain}{p.}{class_attempt__7_1_1_simulation_main} to get the turnIndicator. \item\end{DoxyCompactList}\item 
int {\bf GetSingularitiesNewHough} ()
\begin{DoxyCompactList}\small\item\em Returns the number of times rho=0 in the new hough system. \item\end{DoxyCompactList}\item 
int {\bf GetSingularitesOldHough} ()
\begin{DoxyCompactList}\small\item\em Returns the number of times rho=0 in the Old hough system. \item\end{DoxyCompactList}\item 
Vector3[$\,$] {\bf GetHoughStartandStopVectors} ()
\begin{DoxyCompactList}\small\item\em Gets the array holding information about the hough lines and where to draw them. \item\end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
Color[,] {\bf TextureTo2DArray} (Texture2D texture, Color[$\,$] colors1D, Color[,] colors2D)
\begin{DoxyCompactList}\small\item\em Takes a texture and makes it into a 2D color array. Passing in the arrays is faster than trying to build it each time. \item\end{DoxyCompactList}\item 
bool[,] {\bf FindWhite} (Color[,] colorArray1)
\begin{DoxyCompactList}\small\item\em Takes a 2D color array and finds the pixels that are \char`\"{}white\char`\"{}. \item\end{DoxyCompactList}\item 
bool[,] {\bf Whiteline} (bool[,] whitemap)
\begin{DoxyCompactList}\small\item\em Determines if white pixels meet the Width threshold to possibly be a line. NOT IN USE RIGHT NOW$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$. \item\end{DoxyCompactList}\item 
bool[,] {\bf Smooth} (bool[,] original, bool[,] final)
\begin{DoxyCompactList}\small\item\em Takes a truefalse map and for each pixel checks the other pixels around it to see if they are also white. If the number of pixels arround it that are also white is above a threshold then keep that pixel white. Meant to reduce noise in the picture. NOT IN USE RIGHT NOW$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$. \item\end{DoxyCompactList}\item 
bool[,] {\bf ShowPath} (bool[,] blocked, bool[,] clearPath)
\begin{DoxyCompactList}\small\item\em Find a path through the map to go through and return it as a bool map, also set the turn indicator. Based off the reactiveNavigation from the old robot code. \item\end{DoxyCompactList}\item 
void {\bf FindMaxInAccumArrayOfHough} (short[,] accumToAnalze, short thetaIncrement, short startIndexOfStoringHoughInfoList)
\begin{DoxyCompactList}\small\item\em Finds Max value in Hough. Store information about that max. \item\end{DoxyCompactList}\item 
void {\bf CalculateStartandStopofLine} (double x1, double y1, double slope1, int startIndexforStorageArray)
\begin{DoxyCompactList}\small\item\em Part of the old Hough system. Finds the edge values on the screen of the lines based on the slope and yInt. \item\end{DoxyCompactList}\item 
void {\bf Hough} (bool[,] isLine)
\begin{DoxyCompactList}\small\item\em For each white pixel that might be part of a line, Find all the potiential lines going through it and store each vote for that line in the accumlator's bins. Calls the methods to search through the accumlator to find the bins with the largest values. \item\end{DoxyCompactList}\item 
void {\bf FindAverages} ()
\begin{DoxyCompactList}\small\item\em Find the average theta values. Weigh them according to the rho value of each one. Make a turning desision based off the weighted thetas if turnBytheta is on. \item\end{DoxyCompactList}\item 
short[,] {\bf ClearMaxInAccum} (short[,] accumToChange, int rho, int theta)
\begin{DoxyCompactList}\small\item\em Clears the array arround the maximum. \item\end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
const int {\bf OLD\_\-HOUGH\_\-MODE} = 0
\item 
const int {\bf New\_\-HOUGH\_\-MODE} = 1
\item 
const short {\bf NumberofLinesToFind} = 2
\begin{DoxyCompactList}\small\item\em Number of lines the hough transform should find. \item\end{DoxyCompactList}\item 
const int {\bf AccumLength} = 600
\begin{DoxyCompactList}\small\item\em Size of the Acuumlator's lenght. Must be able to fit the largest posible value of rho. Max rho = Sqrt( ScreenHeight$^\wedge$2+ (ScreenWidth/2)$^\wedge$2), because the origin is the bottom center and the max rho is top left or right. \item\end{DoxyCompactList}\item 
const int {\bf AccumLengthOld} = 810
\begin{DoxyCompactList}\small\item\em lenght of the hold hough accumulator \item\end{DoxyCompactList}\item 
const short {\bf ThetaIncrement} = 3
\begin{DoxyCompactList}\small\item\em How big the steps are for a potiential theta. In degreees. Large values reduce computation but less acurate. \item\end{DoxyCompactList}\item 
const short {\bf RhoIncrement} = 6
\begin{DoxyCompactList}\small\item\em How big the steps are for a potiential rho values. Large values reduce computation but less acurate. \item\end{DoxyCompactList}\item 
const short {\bf UpdateSquareDimForDrawing} = 2
\begin{DoxyCompactList}\small\item\em Inorder to make computations go faster, not every pixels is anylzed every time. 1 out of This value squared is analzed each pass. \item\end{DoxyCompactList}\item 
const short {\bf UpdateSquareDimForAnalysis} = 2
\begin{DoxyCompactList}\small\item\em Inorder to make drawing go faster, not every pixels is updated every time. 1 out of This value squared is updated each pass. \item\end{DoxyCompactList}\item 
const int {\bf ClearArroundMaxDegree} = 5
\begin{DoxyCompactList}\small\item\em Number of degrees around a maximum to clear around before searching the Accumulator again. \item\end{DoxyCompactList}\item 
const int {\bf ClearArroundMaxRho} = 8
\begin{DoxyCompactList}\small\item\em Number of rho values around a maximum to clear around before searching the Accumulator again. \item\end{DoxyCompactList}\item 
const int {\bf SmoothSearchSize} = 4
\begin{DoxyCompactList}\small\item\em Used by the smooth method. Dimension of Number of pixels to look around for the smooth function. This (values$\ast$2)$^\wedge$2 = number of pixels checked. \item\end{DoxyCompactList}\item 
int {\bf currentMode} = 0
\begin{DoxyCompactList}\small\item\em If 0 then Old mode (top left origin), if 1 then New Hough mode( bottom Center). \item\end{DoxyCompactList}\item 
bool {\bf turnIndicatorisTheta} = false
\begin{DoxyCompactList}\small\item\em If true then steering desisions will be based off the theta's of the hough transform. \item\end{DoxyCompactList}\item 
Texture2D {\bf robotCameraView}
\begin{DoxyCompactList}\small\item\em Texture object that represents the robot camera's current view. \item\end{DoxyCompactList}\item 
bool[,] {\bf trueFalseMap}
\begin{DoxyCompactList}\small\item\em TrueFalse maps used for marking pixels either \char`\"{}good\char`\"{} or \char`\"{}bad\char`\"{}. \item\end{DoxyCompactList}\item 
bool[,] {\bf trueFalseMapB}
\item 
bool[,] {\bf trueFalseMapC}
\item 
int {\bf screenWidth}
\begin{DoxyCompactList}\small\item\em Screen Width of the image to analze. \item\end{DoxyCompactList}\item 
int {\bf screenHeight}
\begin{DoxyCompactList}\small\item\em Screen Height of the image to analze. \item\end{DoxyCompactList}\item 
int {\bf turnIndication} = 0
\begin{DoxyCompactList}\small\item\em The turn indicator measures measures how much the analysis things the robot should go right or left. Right = positive. Left = negative. \item\end{DoxyCompactList}\item 
double[$\,$] {\bf houghInfo}
\begin{DoxyCompactList}\small\item\em Stores information about lines from the hough transform. each polarRho we want to find = 7 more values to store 0=slope, 1= yInt, 2=Rho, 3=Theta, 4=Xvalue, 5=Yvalue, 6= size of the bin, 7= xTransformed value 8= yTransformedValue, 9 = distance to line Algorithm, 10= angle to line Algorithm 5 more ending values for the averages. \item\end{DoxyCompactList}\item 
Vector3[$\,$] {\bf houghLineStartandStopVectors}
\begin{DoxyCompactList}\small\item\em Stores vector3 locations of the beginning and end points of two lines on the screen. Was part of the old Hough system, but potientially still useful, so has not deleted. 0 = start location of line, 1 = end location ofline. \item\end{DoxyCompactList}\item 
Color[,] {\bf colorArray}
\begin{DoxyCompactList}\small\item\em Color Array 2D from the robot camera that is analzed. \item\end{DoxyCompactList}\item 
Color[$\,$] {\bf colorArray1D}
\begin{DoxyCompactList}\small\item\em Color Array 2D from the robot camera that is analzed. Can't extract informatino directly from the robot view Texture to 2D. But have to go through 1D array. \item\end{DoxyCompactList}\item 
short {\bf count1A} = 0
\begin{DoxyCompactList}\small\item\em These values are the incremented numbers used in the giant double \char`\"{}for-\/loops\char`\"{}. The \char`\"{}1\char`\"{} values are the for the first \char`\"{}for-\/loop\char`\"{}. \item\end{DoxyCompactList}\item 
short {\bf count1B} = 1
\item 
short {\bf count1C} = 0
\item 
short {\bf count1D} = 1
\item 
short {\bf count1E} = 0
\item 
short {\bf count2A} = 0
\begin{DoxyCompactList}\small\item\em These values are the incremented numbers used in the giant double \char`\"{}for-\/loops\char`\"{}. The \char`\"{}2\char`\"{} values are the for the second \char`\"{}for-\/loop\char`\"{}. \item\end{DoxyCompactList}\item 
short {\bf count2B} = 0
\item 
short {\bf count2C} = 0
\item 
short {\bf count2E} = 0
\item 
int[$\,$] {\bf middleValues}
\begin{DoxyCompactList}\small\item\em An array of the middle clear pixels for each row. The length of the array is the number of rows = this.screenHeight. \item\end{DoxyCompactList}\item 
int {\bf totalWhiteCnt} = 0
\begin{DoxyCompactList}\small\item\em Number of white pixels the \char`\"{}FindWhite\char`\"{} found. \item\end{DoxyCompactList}\item 
short[,] {\bf accum2}
\begin{DoxyCompactList}\small\item\em The accumlator for the hough values. Each position is a hough Bin. Each bin represents a line in Cartessian cordinates. The Accumlator is basically in polar cordinates. Theta,rho. \item\end{DoxyCompactList}\item 
short[,] {\bf accum1}
\item 
int {\bf cntThreshold} = 15
\begin{DoxyCompactList}\small\item\em Used by the smooth method. How many pixels must also be white in the area around a white pixel for it to be counted white. \item\end{DoxyCompactList}\item 
int {\bf redGood}
\begin{DoxyCompactList}\small\item\em On a scale of 0-\/255 how high does a pixel RGB value have to be before being declared white. \item\end{DoxyCompactList}\item 
int {\bf blueGood}
\item 
int {\bf greenGood}
\item 
int {\bf whiteParam} = 150
\begin{DoxyCompactList}\small\item\em Sets red\_\-good, blue\_\-good, green\_\-good to this value. \item\end{DoxyCompactList}\item 
{\bf DrawImageAnalysis} {\bf drawAnalysis}
\begin{DoxyCompactList}\small\item\em The drawingImageAnalysis class handles the vertex information the shows what the robot is thinking. \item\end{DoxyCompactList}\item 
int {\bf countOfNewHoughSingularities} = 0
\item 
int {\bf countofOldHoughSingularities} = 0
\end{DoxyCompactItemize}


\subsection{Detailed Description}
It was easier to redure 640$\ast$480 small triangles and view then from a distance than to put a texture on the GPU So there is a camera to view the triangels. The class only analzes a small fraction of the pixels each time through the game loop inorder to keep the speed high. Many of the methods have loops that cause them to only look at every X pixel each time through and then the next time through a different set. Basically it functions like a giant double \char`\"{}for\char`\"{} loop. The Image Analysis Class does the image processing of the robot view. 

Definition at line 32 of file ImageAnalysis2.cs.



\subsection{Constructor \& Destructor Documentation}
\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!ImageAnalysis@{ImageAnalysis}}
\index{ImageAnalysis@{ImageAnalysis}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{ImageAnalysis}]{\setlength{\rightskip}{0pt plus 5cm}Attempt\_\-7.ImageAnalysis.ImageAnalysis (
\begin{DoxyParamCaption}
\item[{Game}]{game, }
\item[{Vector2}]{screenSize, }
\item[{List$<$ Viewport $>$}]{viewPortList1}
\end{DoxyParamCaption}
)}\label{class_attempt__7_1_1_image_analysis_a372086fbe7753711c79fb65694e74b8b}


Initializes a new instance of the \doxyref{ImageAnalysis}{p.}{class_attempt__7_1_1_image_analysis} class. 


\begin{DoxyParams}{Parameters}
{\em game} & The game associated with the class\\
\hline
{\em screenSize} & The size of the sceen to analze\\
\hline
{\em viewPortList1} & A list of the view ports\\
\hline
\end{DoxyParams}


Definition at line 203 of file ImageAnalysis2.cs.


\begin{DoxyCode}
            : base(game)
        {
            this.screenWidth = (int)screenSize.X;
            this.screenHeight = (int)screenSize.Y;

            // Creates the image drawing analysis object.
            this.drawAnalysis = new DrawImageAnalysis(game, this.screenWidth, thi
      s.screenHeight, UpdateSquareDimForDrawing, UpdateSquareDimForAnalysis, 
      NumberofLinesToFind, ThetaIncrement, RhoIncrement, viewPortList1, this);
            this.drawAnalysis.DrawOrder = game.Components.Count;
            Game.Components.Add(this.drawAnalysis);
        }
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!CalculateStartandStopofLine@{CalculateStartandStopofLine}}
\index{CalculateStartandStopofLine@{CalculateStartandStopofLine}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{CalculateStartandStopofLine}]{\setlength{\rightskip}{0pt plus 5cm}void Attempt\_\-7.ImageAnalysis.CalculateStartandStopofLine (
\begin{DoxyParamCaption}
\item[{double}]{x1, }
\item[{double}]{y1, }
\item[{double}]{slope1, }
\item[{int}]{startIndexforStorageArray}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a327ee82eeb29ad6f4060bb4a9a21d7d8}


Part of the old Hough system. Finds the edge values on the screen of the lines based on the slope and yInt. 


\begin{DoxyParams}{Parameters}
{\em slope1} & Slope of the line\\
\hline
{\em yintercept1} & YIntercept of the line\\
\hline
{\em startIndexforStorageArray} & Where to store the information in the storage array\\
\hline
\end{DoxyParams}


Definition at line 709 of file ImageAnalysis2.cs.


\begin{DoxyCode}
        {
            int startX = 0;
            int startY = 0;
            int endX = 0;
            int endY = 0;
            int yIntReal = 0;
            double slopeReal = 0;

            if (this.currentMode == New_HOUGH_MODE)
            {
                slopeReal = -1 / slope1; // Slope of the actual line-- not the sl
      ope of the line perpendicular (which is what the hough found)
                yIntReal = (int)(y1 - (slopeReal * (x1 + this.screenWidth / 2)));
       // y-intercept of the actual line-- not the slope of the line perpendicular (whi
      ch is what the hough found)

                // So far all the calculations assume origin is in bottom center.
       Now based off that information find the cordinates of where to start and stop
                // the hough lines in screen cordinates. Down is positive y in sc
      reen cordinates.             
                // Left Side
                if (yIntReal >= 0 && yIntReal < this.screenHeight)
                {
                    startX = 0;
                    startY = this.screenHeight - yIntReal;                    
                }
                else if (yIntReal <= 0)
                {                    
                    startX = -(int)(yIntReal / slopeReal);
                    startY = this.screenHeight;
                }
                else if (yIntReal > this.screenHeight)
                {
                    startX = (int)((this.screenHeight - yIntReal) / slopeReal);
                    startY = 0;
                }

                // Find the end cordinates of the line.
                // Right Side          
                int yright = (int)((slopeReal * this.screenWidth) + yIntReal);

                if (yright > 0 && yright < this.screenHeight)
                {                    
                    endX = this.screenWidth;
                    endY = this.screenHeight - yright;
                }
                else if (yright < 0)
                {
                    endX = (int)(-yIntReal / slopeReal);
                    endY = this.screenHeight;
                }
                else

                    if (yright > this.screenHeight)
                    {
                        endX = (int)((this.screenHeight - yIntReal) / slopeReal);
      
                        endY = 0;
                    }
            }

            if (this.currentMode == OLD_HOUGH_MODE)
            {
                // remember that origin is top left corner and down is positive y
      
                slopeReal = -1 / -slope1;
                yIntReal = (int)(-y1 - (slopeReal * x1));

                if (yIntReal >= 0)
                {
                    startX = (int)(-yIntReal / slopeReal);
                    startY = 0;
                }

                if (yIntReal <= 0 && yIntReal > -this.screenHeight)
                {
                    startX = 0;
                    startY = -(int)yIntReal;
                }

                if (yIntReal < -this.screenHeight)
                {
                    startX = (int)((-this.screenHeight - yIntReal) / slopeReal);
                    startY = this.screenHeight;
                }

                // Find the end cordinates of the line.
                // Right Side          
                int yright = (int)((slopeReal * this.screenWidth) + yIntReal);

                if (yright > 0)
                {
                    endX = (int)(-yIntReal / slopeReal);
                    endY = 0;
                }

                if (yright < 0 && yright > -this.screenHeight)
                {
                    endX = this.screenWidth;
                    endY = -yright;
                }

                if (yright < -this.screenHeight)
                {
                    endX = (int)((-this.screenHeight - yIntReal) / slopeReal);
                    endY = this.screenHeight;
                }

            }

            // Store the Line information in the array 'houghLineStartandStopVect
      ors' starting at the value 'startIndexforStorageArray'
            this.houghLineStartandStopVectors[startIndexforStorageArray + 0] = ne
      w Vector3(startX, startY, 0);
            this.houghLineStartandStopVectors[startIndexforStorageArray + 1] = ne
      w Vector3(endX, endY, 0);
        }
\end{DoxyCode}


Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{class_attempt__7_1_1_image_analysis_a327ee82eeb29ad6f4060bb4a9a21d7d8_icgraph}
\end{center}
\end{figure}


\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!ClearMaxInAccum@{ClearMaxInAccum}}
\index{ClearMaxInAccum@{ClearMaxInAccum}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{ClearMaxInAccum}]{\setlength{\rightskip}{0pt plus 5cm}short [,] Attempt\_\-7.ImageAnalysis.ClearMaxInAccum (
\begin{DoxyParamCaption}
\item[{short}]{accumToChange[,], }
\item[{int}]{rho, }
\item[{int}]{theta}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a00bfc4bb52ece15ba645b81fb3ca3f2b}


Clears the array arround the maximum. 


\begin{DoxyParams}{Parameters}
{\em accumToChange} & The accumulator to clear around\\
\hline
{\em rho} & the rho value to clear around\\
\hline
{\em theta} & the theta value to clear around\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the accumulator array that is cleared around
\end{DoxyReturn}


Definition at line 982 of file ImageAnalysis2.cs.


\begin{DoxyCode}
        {
            rho = rho / RhoIncrement;
            theta = theta / ThetaIncrement;

            int accumDim1 = accumToChange.GetLength(0); // Get the size accum Arr
      ay
            int accumDim2 = accumToChange.GetLength(1);

            // Clear the one with the most votes
            for (int degree = -ClearArroundMaxDegree / ThetaIncrement; degree < 
      ClearArroundMaxDegree / ThetaIncrement; degree++)
            {
                for (int phi = -ClearArroundMaxRho / RhoIncrement; phi < 
      ClearArroundMaxRho / RhoIncrement; phi++)
                {
                    int thetaprime = (theta + degree) % accumDim1;
                    int rhoprime = (rho + phi) % accumDim2;
                    if (thetaprime > 0 && thetaprime < accumDim1 && rhoprime > 0 
      && rhoprime < accumDim2)
                    {
                        accumToChange[thetaprime, rhoprime] = 0;
                    }
                }
            }

            return accumToChange;
        }
\end{DoxyCode}


Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{class_attempt__7_1_1_image_analysis_a00bfc4bb52ece15ba645b81fb3ca3f2b_icgraph}
\end{center}
\end{figure}


\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!FindAverages@{FindAverages}}
\index{FindAverages@{FindAverages}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{FindAverages}]{\setlength{\rightskip}{0pt plus 5cm}void Attempt\_\-7.ImageAnalysis.FindAverages (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_aa983bdc246185a5a41414e1db84534dd}


Find the average theta values. Weigh them according to the rho value of each one. Make a turning desision based off the weighted thetas if turnBytheta is on. 



Definition at line 941 of file ImageAnalysis2.cs.


\begin{DoxyCode}
        {
            int thetaSum = 0;
            int rhoSum = 0;
            int count = 0;
            int rho = -1;
            int theta = -1;
            int binSize = 0;
            int turn = -1;

            for (int i = 0; i < NumberofLinesToFind; i++)
            {
                // If the rho or theta are the same as the last one, then don't c
      ount it. 
                if (this.houghInfo[((i * 11) + 4)] != rho && this.houghInfo[((i *
       11) + 5)] != theta && this.houghInfo[((i * 11) + 6)] * 1.5 > binSize)
                {
                    rho = (int)this.houghInfo[((i * 11) + 2)]; // Sum the rhos
                    theta = (int)this.houghInfo[((i * 11) + 3)]; // Sum the theta
      s
                    binSize = (int)this.houghInfo[((i * 11) + 4)]; // Get bin siz
      e
                    rhoSum += rho;
                    thetaSum += theta;
                    turn += (int)((theta - 90) * (double)((i / NumberofLinesToFin
      d) * (577 - rho) / 500));
                    count++;
                }
            }

            int averageTheta = thetaSum / count;
            this.houghInfo[NumberofLinesToFind * 11] = averageTheta; // Compute a
      nd store the averages
            this.houghInfo[(NumberofLinesToFind * 11) + 1] = rhoSum / count;
            if (this.turnIndicatorisTheta == true)
            {
                this.turnIndication = turn;
            }
        }
\end{DoxyCode}


Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{class_attempt__7_1_1_image_analysis_aa983bdc246185a5a41414e1db84534dd_icgraph}
\end{center}
\end{figure}


\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!FindMaxInAccumArrayOfHough@{FindMaxInAccumArrayOfHough}}
\index{FindMaxInAccumArrayOfHough@{FindMaxInAccumArrayOfHough}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{FindMaxInAccumArrayOfHough}]{\setlength{\rightskip}{0pt plus 5cm}void Attempt\_\-7.ImageAnalysis.FindMaxInAccumArrayOfHough (
\begin{DoxyParamCaption}
\item[{short}]{accumToAnalze[,], }
\item[{short}]{thetaIncrement, }
\item[{short}]{startIndexOfStoringHoughInfoList}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a74a456e2880a858c96a7d8802250c504}


Finds Max value in Hough. Store information about that max. 


\begin{DoxyParams}{Parameters}
{\em accumToAnalze} & The accumlator of bins we want to search\\
\hline
{\em thetaIncrement} & How large is the quantitization of the theta values. \\
\hline
{\em startIndexOfStoringHoughInfoList} & What value in the Array 'HoughInfo' should we start storing information.\\
\hline
\end{DoxyParams}


\{(x$^\wedge$3 -\/ b x y + a y$^\wedge$2 + x y$^\wedge$2)/(x$^\wedge$2 + y$^\wedge$2), x$^\wedge$2/y + y -\/ (x (x$^\wedge$3 -\/ b x y + a y$^\wedge$2 + x y$^\wedge$2))/(y (x$^\wedge$2 + y$^\wedge$2))\} 



Definition at line 599 of file ImageAnalysis2.cs.


\begin{DoxyCode}
        {
            int maxTheta = 1;
            int maxRho = 1;
            int maxAccum = 1;
            int accumDim1 = accumToAnalze.GetLength(0);
            int accumDim2 = accumToAnalze.GetLength(1);

            // Run through to find cell with most votes
            for (int s = 0; s < accumDim1; s++)
            {
                for (int t = 0; t < accumDim2; t++)
                {
                    if (accumToAnalze[s, t] > maxAccum)
                    {
                        maxTheta = s;
                        maxRho = t;
                        maxAccum = accumToAnalze[s, t];
                    }
                }
            }

            double slope1 = 1;
            int yintercept1 = 0;
            double x1 = 0;
            double y1 = 0;

            if (this.currentMode == New_HOUGH_MODE)
            {
                maxTheta *= thetaIncrement; // Scale the Theta back to real size.
      
                maxRho = maxRho * RhoIncrement; // Scale the Rho back to real siz
      e.
                x1 = (int)(maxRho * Math.Cos(MathHelper.ToRadians(maxTheta))); //
       Find the x Point corresponding the theta, rho
                y1 = (int)(maxRho * Math.Sin(MathHelper.ToRadians(maxTheta))); //
       Find the y Point corresponding the theta, rho               

                if (x1 == 0)
                {
                    x1 = 0.00001; // don't divide by zero
                }
                slope1 = Math.Round(Math.Tan(MathHelper.ToRadians(maxTheta)), 2);
       // Calculating the slope and round to 2 digits.                
                yintercept1 = (int)(y1 - (slope1 * x1));

                // Store the information found about the line in the 'this.houghI
      nfo' array starting at the value 'StartIndexOfStoringHoughInfoList'
                this.houghInfo[startIndexOfStoringHoughInfoList + 0] = slope1;
                this.houghInfo[startIndexOfStoringHoughInfoList + 1] = yintercept
      1;
                this.houghInfo[startIndexOfStoringHoughInfoList + 2] = maxRho;
                this.houghInfo[startIndexOfStoringHoughInfoList + 3] = maxTheta;
                this.houghInfo[startIndexOfStoringHoughInfoList + 4] = x1;
                this.houghInfo[startIndexOfStoringHoughInfoList + 5] = y1;
                this.houghInfo[startIndexOfStoringHoughInfoList + 6] = maxAccum;
            }

            if (this.currentMode == OLD_HOUGH_MODE)
            {
                maxTheta = (thetaIncrement * maxTheta) - 180; // Scale the Theta 
      back to real size.
                maxRho = maxRho * RhoIncrement; // Scale the Rho back to real siz
      e.
                x1 = (int)(maxRho * Math.Cos(MathHelper.ToRadians(maxTheta))); //
       Find the x Point corresponding the theta, rho
                y1 = (int)(maxRho * Math.Sin(MathHelper.ToRadians(maxTheta))); //
       Find the y Point corresponding the theta, rho               

                if (x1 == 0)
                {
                    x1 = 0.00001; // don't divide by zero
                }
                slope1 = Math.Round(Math.Tan(MathHelper.ToRadians(maxTheta)), 2);
       // Calculating the slope and round to 2 digits.                
                yintercept1 = (int)(y1 - (slope1 * x1));


                int distance = 0;
                int angle = 0;
                int a = this.screenWidth / 2;
                int b = this.screenHeight;

                double xTransformed = (int)((Math.Pow(x1, 3) - b * x1 * y1 + a * 
      Math.Pow(y1, 2) + x1 * Math.Pow(y1, 2)) / (Math.Pow(x1, 2) + Math.Pow(y1, 2)));
                double yTransformed = (int)(Math.Pow(x1, 2) / y1 + y1 - (x1 * (Ma
      th.Pow(x1, 3) - b * x1 * y1 + a * Math.Pow(y1, 2) + x1 * Math.Pow(y1, 2))) / (y1 
      * (Math.Pow(x1, 2) + Math.Pow(y1, 2))));

                distance = (int)Math.Sqrt(Math.Pow(xTransformed - a, 2) + Math.Po
      w(b - yTransformed, 2));
                angle = (int)MathHelper.ToDegrees((float)Math.Atan((b - yTransfor
      med) / (xTransformed - a)));

                if (angle < 0)
                {
                    angle += 180;
                }

                // Store the information found about the line in the 'this.houghI
      nfo' array starting at the value 'StartIndexOfStoringHoughInfoList'
                this.houghInfo[startIndexOfStoringHoughInfoList + 0] = slope1;
                this.houghInfo[startIndexOfStoringHoughInfoList + 1] = yintercept
      1;
                this.houghInfo[startIndexOfStoringHoughInfoList + 2] = maxRho;
                this.houghInfo[startIndexOfStoringHoughInfoList + 3] = maxTheta +
       180; // Stay in the range of the array. 
                this.houghInfo[startIndexOfStoringHoughInfoList + 4] = x1;
                this.houghInfo[startIndexOfStoringHoughInfoList + 5] = y1;
                this.houghInfo[startIndexOfStoringHoughInfoList + 6] = maxAccum;
                this.houghInfo[startIndexOfStoringHoughInfoList + 7] = xTransform
      ed;
                this.houghInfo[startIndexOfStoringHoughInfoList + 8] = yTransform
      ed;
                this.houghInfo[startIndexOfStoringHoughInfoList + 9] = distance; 
      // distance to line. 
                this.houghInfo[startIndexOfStoringHoughInfoList + 10] = angle; //
       angle to line. 
            }

        }
\end{DoxyCode}


Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{class_attempt__7_1_1_image_analysis_a74a456e2880a858c96a7d8802250c504_icgraph}
\end{center}
\end{figure}


\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!FindWhite@{FindWhite}}
\index{FindWhite@{FindWhite}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{FindWhite}]{\setlength{\rightskip}{0pt plus 5cm}bool [,] Attempt\_\-7.ImageAnalysis.FindWhite (
\begin{DoxyParamCaption}
\item[{Color}]{colorArray1[,]}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a9418e8e0a6868d294d27b97cadf6d958}


Takes a 2D color array and finds the pixels that are \char`\"{}white\char`\"{}. 


\begin{DoxyParams}{Parameters}
{\em colorArray1} & The color array to find white in.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The TrueFalse bool map of white pixels. True = white, False = not white. 
\end{DoxyReturn}


Definition at line 409 of file ImageAnalysis2.cs.


\begin{DoxyCode}
        {
            // True = bad, False = good.
            this.totalWhiteCnt = 0;
            int i, j;
            bool[,] trueFalseMap = new bool[colorArray1.GetLength(0), colorArray1
      .GetLength(1)]; // Create the bool map.

            for (i = 0; i < this.screenWidth; ++i)
            {
                for (j = 0; j < this.screenHeight; ++j)
                {
                    // If above the thresholds. 
                    if ((colorArray1[i, j].R > this.redGood)
                        && (colorArray1[i, j].G > this.greenGood)
                        && (colorArray1[i, j].B > this.blueGood))
                    {
                        trueFalseMap[i, j] = true;
                        this.totalWhiteCnt++;
                    }
                    else
                    {
                        trueFalseMap[i, j] = false;
                    }
                }
            }

            return trueFalseMap;
        }
\end{DoxyCode}


Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{class_attempt__7_1_1_image_analysis_a9418e8e0a6868d294d27b97cadf6d958_icgraph}
\end{center}
\end{figure}


\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!GetColorMapToDraw@{GetColorMapToDraw}}
\index{GetColorMapToDraw@{GetColorMapToDraw}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{GetColorMapToDraw}]{\setlength{\rightskip}{0pt plus 5cm}Color [,] Attempt\_\-7.ImageAnalysis.GetColorMapToDraw (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{class_attempt__7_1_1_image_analysis_ab8604cecb2f620a88298bccc48a4436d}


Gets the Color map to be drawn. 

\begin{DoxyReturn}{Returns}
Color map
\end{DoxyReturn}


Definition at line 342 of file ImageAnalysis2.cs.


\begin{DoxyCode}
        {
            return this.colorArray;
        }
\end{DoxyCode}
\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!GetHoughInfo@{GetHoughInfo}}
\index{GetHoughInfo@{GetHoughInfo}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{GetHoughInfo}]{\setlength{\rightskip}{0pt plus 5cm}double [$\,$] Attempt\_\-7.ImageAnalysis.GetHoughInfo (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{class_attempt__7_1_1_image_analysis_a897a0f80fbf65670828c8a1a1db13d97}


Gets the houghInfo Array. 

\begin{DoxyReturn}{Returns}
houghInfo Array
\end{DoxyReturn}


Definition at line 304 of file ImageAnalysis2.cs.


\begin{DoxyCode}
        {
            return this.houghInfo;
        }
\end{DoxyCode}


Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{class_attempt__7_1_1_image_analysis_a897a0f80fbf65670828c8a1a1db13d97_icgraph}
\end{center}
\end{figure}


\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!GetHoughMode@{GetHoughMode}}
\index{GetHoughMode@{GetHoughMode}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{GetHoughMode}]{\setlength{\rightskip}{0pt plus 5cm}string Attempt\_\-7.ImageAnalysis.GetHoughMode (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{class_attempt__7_1_1_image_analysis_ae14af27b7aaa3d4a1006af2a56ab14d1}


Gets the Hough mode. 0 = Old, 1 = New. 

\begin{DoxyReturn}{Returns}
\char`\"{}Old\char`\"{} if in the old mode, \char`\"{}New\char`\"{} if in the new mode
\end{DoxyReturn}


Definition at line 322 of file ImageAnalysis2.cs.


\begin{DoxyCode}
        {
            string mode = string.Empty;

            if (this.currentMode == 0)
            {
                mode = "Old";
            }
            else
            {
                mode = "New";
            }

            return mode;
        }
\end{DoxyCode}


Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{class_attempt__7_1_1_image_analysis_ae14af27b7aaa3d4a1006af2a56ab14d1_icgraph}
\end{center}
\end{figure}


\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!GetHoughStartandStopVectors@{GetHoughStartandStopVectors}}
\index{GetHoughStartandStopVectors@{GetHoughStartandStopVectors}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{GetHoughStartandStopVectors}]{\setlength{\rightskip}{0pt plus 5cm}Vector3 [$\,$] Attempt\_\-7.ImageAnalysis.GetHoughStartandStopVectors (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{class_attempt__7_1_1_image_analysis_a3c35b4a6a6a1e4464fc79772caa612cf}


Gets the array holding information about the hough lines and where to draw them. 

\begin{DoxyReturn}{Returns}
Array of Vector3 with the locations of where to start and stop hough lines
\end{DoxyReturn}


Definition at line 378 of file ImageAnalysis2.cs.


\begin{DoxyCode}
        {
            return this.houghLineStartandStopVectors;
        }
\end{DoxyCode}


Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{class_attempt__7_1_1_image_analysis_a3c35b4a6a6a1e4464fc79772caa612cf_icgraph}
\end{center}
\end{figure}


\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!GetSingularitesOldHough@{GetSingularitesOldHough}}
\index{GetSingularitesOldHough@{GetSingularitesOldHough}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{GetSingularitesOldHough}]{\setlength{\rightskip}{0pt plus 5cm}int Attempt\_\-7.ImageAnalysis.GetSingularitesOldHough (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{class_attempt__7_1_1_image_analysis_a8b8e7e705c97bbb5da1300c139ec0f36}


Returns the number of times rho=0 in the Old hough system. 

\begin{DoxyReturn}{Returns}
Number of times rho = 0
\end{DoxyReturn}


Definition at line 369 of file ImageAnalysis2.cs.


\begin{DoxyCode}
        {
            return this.countofOldHoughSingularities;
        }
\end{DoxyCode}


Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{class_attempt__7_1_1_image_analysis_a8b8e7e705c97bbb5da1300c139ec0f36_icgraph}
\end{center}
\end{figure}


\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!GetSingularitiesNewHough@{GetSingularitiesNewHough}}
\index{GetSingularitiesNewHough@{GetSingularitiesNewHough}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{GetSingularitiesNewHough}]{\setlength{\rightskip}{0pt plus 5cm}int Attempt\_\-7.ImageAnalysis.GetSingularitiesNewHough (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{class_attempt__7_1_1_image_analysis_a23adf47c39e8990ae161dd46dcb43846}


Returns the number of times rho=0 in the new hough system. 

\begin{DoxyReturn}{Returns}
number of times rho = 0
\end{DoxyReturn}


Definition at line 360 of file ImageAnalysis2.cs.


\begin{DoxyCode}
        {
            return this.countOfNewHoughSingularities;
        }
\end{DoxyCode}


Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{class_attempt__7_1_1_image_analysis_a23adf47c39e8990ae161dd46dcb43846_icgraph}
\end{center}
\end{figure}


\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!GetTrueFalseMaptoDraw@{GetTrueFalseMaptoDraw}}
\index{GetTrueFalseMaptoDraw@{GetTrueFalseMaptoDraw}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{GetTrueFalseMaptoDraw}]{\setlength{\rightskip}{0pt plus 5cm}bool [,] Attempt\_\-7.ImageAnalysis.GetTrueFalseMaptoDraw (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{class_attempt__7_1_1_image_analysis_a1ba8eee3151c73ef5023003ee7b57b67}


Allows access to the bool map that is to be drawn. 

\begin{DoxyReturn}{Returns}
bool map
\end{DoxyReturn}


Definition at line 313 of file ImageAnalysis2.cs.


\begin{DoxyCode}
        {
            return this.trueFalseMapC;
        }
\end{DoxyCode}


Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{class_attempt__7_1_1_image_analysis_a1ba8eee3151c73ef5023003ee7b57b67_icgraph}
\end{center}
\end{figure}


\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!GetTurnIndicator@{GetTurnIndicator}}
\index{GetTurnIndicator@{GetTurnIndicator}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{GetTurnIndicator}]{\setlength{\rightskip}{0pt plus 5cm}int Attempt\_\-7.ImageAnalysis.GetTurnIndicator (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{class_attempt__7_1_1_image_analysis_a99c5e65fe48a1145d7c9afba96bfb220}


Allows the \doxyref{SimulationMain}{p.}{class_attempt__7_1_1_simulation_main} to get the turnIndicator. 

\begin{DoxyReturn}{Returns}
The turn Indicator
\end{DoxyReturn}


Definition at line 351 of file ImageAnalysis2.cs.


\begin{DoxyCode}
        {
            return this.turnIndication;
        }
\end{DoxyCode}


Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{class_attempt__7_1_1_image_analysis_a99c5e65fe48a1145d7c9afba96bfb220_icgraph}
\end{center}
\end{figure}


\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!GetWhiteCount@{GetWhiteCount}}
\index{GetWhiteCount@{GetWhiteCount}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{GetWhiteCount}]{\setlength{\rightskip}{0pt plus 5cm}int Attempt\_\-7.ImageAnalysis.GetWhiteCount (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{class_attempt__7_1_1_image_analysis_a55b77047aaacc5a78fcd70401da3b069}


Allows access to the WhiteCount in the image. 

\begin{DoxyReturn}{Returns}
The number of white pixels
\end{DoxyReturn}


Definition at line 295 of file ImageAnalysis2.cs.


\begin{DoxyCode}
        {
            return this.totalWhiteCnt;
        }
\end{DoxyCode}


Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{class_attempt__7_1_1_image_analysis_a55b77047aaacc5a78fcd70401da3b069_icgraph}
\end{center}
\end{figure}


\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!Hough@{Hough}}
\index{Hough@{Hough}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{Hough}]{\setlength{\rightskip}{0pt plus 5cm}void Attempt\_\-7.ImageAnalysis.Hough (
\begin{DoxyParamCaption}
\item[{bool}]{isLine[,]}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a89a87d17049aa2c3f1b31af9b8ffcb07}


For each white pixel that might be part of a line, Find all the potiential lines going through it and store each vote for that line in the accumlator's bins. Calls the methods to search through the accumlator to find the bins with the largest values. 


\begin{DoxyParams}{Parameters}
{\em isLine} & The trueFalse array of pixels that might be part of a line. \\
\hline
\end{DoxyParams}


Definition at line 823 of file ImageAnalysis2.cs.


\begin{DoxyCode}
        {
            // Find all possible lines through each point and put into array bin.
      
            for (short x = this.count1E; x < this.screenWidth; x += 
      UpdateSquareDimForAnalysis)
            {
                for (short y = this.count2E; y < this.screenHeight; y += 
      UpdateSquareDimForAnalysis)
                {
                    if (isLine[x, y] == true)
                    {
                        if (this.currentMode == New_HOUGH_MODE)
                        {
                            for (short theta = 0; theta < 180; theta += 
      ThetaIncrement)
                            {
                                // Bottom center = origin. 
                                short xprime = (short)(x - (this.screenWidth / 2)
      );
                                short yprime = (short)(-y + this.screenHeight);
                                short rhoprime = (short)(((xprime * Math.Cos(Math
      Helper.ToRadians(theta))) + (yprime * Math.Sin(MathHelper.ToRadians(theta)))) / 
      RhoIncrement);
                                if (rhoprime >= 0)
                                {
                                    this.accum2[theta / ThetaIncrement, rhoprime]
      ++;
                                }

                                // because that would represent a line that is no
      t on the screen
                                else 
                                {
                                    this.accum2[(theta + 180) / ThetaIncrement, -
      rhoprime]++;
                                }


                            }
                        }

                        if (this.currentMode == OLD_HOUGH_MODE)
                        {
                            for (short theta = -180; theta < 180; theta += 
      ThetaIncrement)
                            {
                                short rho = (short)(((x * Math.Cos(MathHelper.ToR
      adians(theta))) + (y * Math.Sin(MathHelper.ToRadians(theta)))) / RhoIncrement);
                                if (rho > 0)
                                {
                                    this.accum1[(theta + 180) / ThetaIncrement, r
      ho]++;
                                }
                            }
                        }
                    }
                }
            }

            this.count1E++;
            if (this.count1E == UpdateSquareDimForAnalysis)
            {
                this.count1E = 0;
                this.count2E++;
                if (this.count2E == UpdateSquareDimForAnalysis)
                {
                    // Find the largest values. 
                    for (int i = 0; i < NumberofLinesToFind; i++)
                    {
                        if (this.currentMode == New_HOUGH_MODE)
                        {
                            this.FindMaxInAccumArrayOfHough(this.accum2, 
      ThetaIncrement, (short)(i * 11));
                            this.CalculateStartandStopofLine(this.houghInfo[4 + (
      i * 11)], this.houghInfo[5 + (i * 11)], this.houghInfo[0 + (i * 11)], i * 4);
                            this.ClearMaxInAccum(this.accum2, (int)this.
      houghInfo[(i * 11) + 2], (int)this.houghInfo[(i * 11) + 3]);
                        }

                        if (this.currentMode == OLD_HOUGH_MODE)
                        {
                            this.FindMaxInAccumArrayOfHough(this.accum1, 
      ThetaIncrement, (short)(i * 11));
                            this.CalculateStartandStopofLine(this.houghInfo[4 + (
      i * 11)], this.houghInfo[5 + (i * 11)], this.houghInfo[0 + (i * 11)], i * 4);

                            // From top (0,0) to perpendicular
                            this.houghLineStartandStopVectors[i * 4 + 2] = new Ve
      ctor3((float)this.houghInfo[i * 11 + 4], (float)this.houghInfo[i * 11 + 5], 0);

                            // From bottom center to perpendicular
                            this.houghLineStartandStopVectors[i * 4 + 3] = new Ve
      ctor3((float)this.houghInfo[i * 11 + 7], (float)this.houghInfo[i * 11 + 8], 0);

                            this.ClearMaxInAccum(this.accum1, (int)this.
      houghInfo[(i * 11) + 2], (int)this.houghInfo[(i * 11) + 3]);
                        }
                    }

                    if (this.currentMode == New_HOUGH_MODE)
                    {
                        this.FindAverages(); // Find the average rho and theta
                        Array.Clear(this.accum2, 0, this.accum2.Length); // Clear
       the accumulator
                    }

                    if (this.currentMode == OLD_HOUGH_MODE)
                    {
                        Array.Clear(this.accum1, 0, this.accum1.Length); // Clear
       the accumulator                       

                    }

                    this.count2E = 0;
                }
            }
        }
\end{DoxyCode}


Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{class_attempt__7_1_1_image_analysis_a89a87d17049aa2c3f1b31af9b8ffcb07_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{class_attempt__7_1_1_image_analysis_a89a87d17049aa2c3f1b31af9b8ffcb07_icgraph}
\end{center}
\end{figure}


\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!Initialize@{Initialize}}
\index{Initialize@{Initialize}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{Initialize}]{\setlength{\rightskip}{0pt plus 5cm}override void Attempt\_\-7.ImageAnalysis.Initialize (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{class_attempt__7_1_1_image_analysis_af250995c0e8937dc0ad3c26239716225}


Called when the class is initialized. Creates many of the arrays and sets many of the values. 



Definition at line 218 of file ImageAnalysis2.cs.


\begin{DoxyCode}
        {
            // Create the arrays needed. Building them now will save CPU later. 
            this.trueFalseMap = new bool[this.screenWidth, this.screenHeight];
            this.trueFalseMapB = new bool[this.screenWidth, this.screenHeight];
            this.trueFalseMapC = new bool[this.screenWidth, this.screenHeight];

            this.accum2 = new short[360 / ThetaIncrement, AccumLength / 
      RhoIncrement]; // Build the accumlator array. Make is smaller or shorter based on
       the size of the rho and theta increments
            this.accum1 = new short[360 / ThetaIncrement, AccumLengthOld / 
      RhoIncrement];
            this.colorArray1D = new Color[this.screenWidth * this.screenHeight]; 
      // Create a 1D array of color
            this.colorArray = new Color[this.screenWidth, this.screenHeight]; // 
      Create a 2D array of color

            this.houghInfo = new double[(11 * NumberofLinesToFind) + 5]; // Make 
      the array to store hough information. Must be double so that slopes which are fra
      ctions can be stored

            // Set the color thresholds
            this.redGood = this.whiteParam;
            this.blueGood = this.whiteParam;
            this.greenGood = this.whiteParam;

            this.houghLineStartandStopVectors = new Vector3[NumberofLinesToFind *
       4];
            for (int i = 0; i < NumberofLinesToFind * 4; i++)
            {
                this.houghLineStartandStopVectors[i] = Vector3.Zero;
            }

            this.middleValues = new int[this.screenHeight]; // Steering desisions
       are based off the average middle clear value for each row

            base.Initialize();
        }
\end{DoxyCode}
\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!SetRobotCameraView@{SetRobotCameraView}}
\index{SetRobotCameraView@{SetRobotCameraView}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{SetRobotCameraView}]{\setlength{\rightskip}{0pt plus 5cm}void Attempt\_\-7.ImageAnalysis.SetRobotCameraView (
\begin{DoxyParamCaption}
\item[{Texture2D}]{text}
\end{DoxyParamCaption}
)}\label{class_attempt__7_1_1_image_analysis_aa6cac5de12d6bf454500ee5498db48cb}


Takes a 2D renderTarget/Texture and sets it as the image to analze. Explicitly called in the \doxyref{SimulationMain}{p.}{class_attempt__7_1_1_simulation_main} Draw Method. 


\begin{DoxyParams}{Parameters}
{\em text} & The texture to analze. \\
\hline
\end{DoxyParams}


Definition at line 264 of file ImageAnalysis2.cs.


\begin{DoxyCode}
        {
            this.robotCameraView = text;
        }
\end{DoxyCode}


Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{class_attempt__7_1_1_image_analysis_aa6cac5de12d6bf454500ee5498db48cb_icgraph}
\end{center}
\end{figure}


\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!ShowPath@{ShowPath}}
\index{ShowPath@{ShowPath}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{ShowPath}]{\setlength{\rightskip}{0pt plus 5cm}bool [,] Attempt\_\-7.ImageAnalysis.ShowPath (
\begin{DoxyParamCaption}
\item[{bool}]{blocked[,], }
\item[{bool}]{clearPath[,]}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a0befd0244fb507716329010283730fb6}


Find a path through the map to go through and return it as a bool map, also set the turn indicator. Based off the reactiveNavigation from the old robot code. 


\begin{DoxyParams}{Parameters}
{\em blocked} & The trueFalse map of pixels that are blocked.\\
\hline
{\em clearPath} & Blank. This map will be turned.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The trueFalse map of a clear path.
\end{DoxyReturn}


Definition at line 550 of file ImageAnalysis2.cs.


\begin{DoxyCode}
        {
            int lastRightX = this.screenWidth, lastLeftX = 0;
            int leftX, rightX;
            int sum = 0;

            for (int rowNumber = this.screenHeight - this.count1D - 1; rowNumber 
      > 0; rowNumber -= UpdateSquareDimForAnalysis)
            {
                // Start in the middle
                leftX = (int)((lastLeftX + lastRightX) / 2);

                // Search starting in the middle and bottom of picture and go lef
      t (i.e. subtract) for a blocked pixel
                while (leftX > lastLeftX && blocked[leftX, rowNumber] == false)
                {
                    clearPath[leftX, rowNumber] = true;
                    leftX--;
                }

                // Start in the middle and bottome go right 
                rightX = (int)((lastLeftX + lastRightX) / 2);

                while (rightX < lastRightX && blocked[rightX, rowNumber] == false
      )
                {
                    clearPath[rightX, rowNumber] = true;
                    rightX++;
                }

                lastLeftX = leftX;
                lastRightX = rightX;
                sum += (int)((lastLeftX + lastRightX) / 2);
            }

            this.count1D++;
            if (this.count1D == UpdateSquareDimForAnalysis)
            {
                this.count1D = 0;
            }

            // Find the average middle pixels for each row and set the turn indic
      ator based on this value. 
            this.turnIndication = ((sum * UpdateSquareDimForAnalysis) / this.
      screenHeight) - (this.screenWidth / 2);
            return clearPath;
        }
\end{DoxyCode}


Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{class_attempt__7_1_1_image_analysis_a0befd0244fb507716329010283730fb6_icgraph}
\end{center}
\end{figure}


\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!Smooth@{Smooth}}
\index{Smooth@{Smooth}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{Smooth}]{\setlength{\rightskip}{0pt plus 5cm}bool [,] Attempt\_\-7.ImageAnalysis.Smooth (
\begin{DoxyParamCaption}
\item[{bool}]{original[,], }
\item[{bool}]{final[,]}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a87fb97262f08f3b21afd2bcdb29bbe6c}


Takes a truefalse map and for each pixel checks the other pixels around it to see if they are also white. If the number of pixels arround it that are also white is above a threshold then keep that pixel white. Meant to reduce noise in the picture. NOT IN USE RIGHT NOW$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$. 


\begin{DoxyParams}{Parameters}
{\em original} & The raw truefalse map of whie pixels.\\
\hline
{\em final} & The trueFalse map to modify\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The truefalse map of pixels that met the threshold requirements. 
\end{DoxyReturn}


Definition at line 489 of file ImageAnalysis2.cs.


\begin{DoxyCode}
        {
            int cnt;
            for (int i = this.count1B; i < this.screenWidth; i += 
      UpdateSquareDimForAnalysis)
            {
                for (int j = this.count2B; j < this.screenHeight; j += 
      UpdateSquareDimForAnalysis)
                {
                    if (original[i, j] == true)
                    {
                        cnt = 0;
                        for (int a = -SmoothSearchSize; a <= SmoothSearchSize; a+
      +)
                        {
                            for (int b = -SmoothSearchSize; b <= 
      SmoothSearchSize; b++)
                            {
                                if (i + a > -1 && i + a < this.screenWidth && j +
       b > -1 && j + b < this.screenHeight)
                                {
                                    if (original[i + a, j + b] == true)
                                    {
                                        cnt = cnt + 1;
                                    }
                                }
                            }
                        }

                        if (cnt > this.cntThreshold)
                        {
                            final[i, j] = true;
                        }
                        else
                        {
                            final[i, j] = false;
                        }
                    }
                    else
                    {
                        final[i, j] = false;
                    }
                }
            }

            this.count1B++;
            if (this.count1B == UpdateSquareDimForDrawing)
            {
                this.count1B = 0;
                this.count2B++;
                if (this.count2B == UpdateSquareDimForDrawing)
                {
                    this.count2B = 0;
                }
            }

            return final;
        }
\end{DoxyCode}
\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!TextureTo2DArray@{TextureTo2DArray}}
\index{TextureTo2DArray@{TextureTo2DArray}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{TextureTo2DArray}]{\setlength{\rightskip}{0pt plus 5cm}Color [,] Attempt\_\-7.ImageAnalysis.TextureTo2DArray (
\begin{DoxyParamCaption}
\item[{Texture2D}]{texture, }
\item[{Color[$\,$]}]{colors1D, }
\item[{Color}]{colors2D[,]}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_ac70a680405b76bd8b0ece8ee2a8112e8}


Takes a texture and makes it into a 2D color array. Passing in the arrays is faster than trying to build it each time. 


\begin{DoxyParams}{Parameters}
{\em texture} & Texture to extract color information\\
\hline
{\em colors1D} & 1D array needed for the extraction\\
\hline
{\em colors2D} & 2D array that will be returned\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The 2D color array of the texture color information
\end{DoxyReturn}


Definition at line 390 of file ImageAnalysis2.cs.


\begin{DoxyCode}
        {
            texture.GetData(colors1D);
            for (int x = 0; x < texture.Width; x++)
            {
                for (int y = 0; y < texture.Height; y++)
                {
                    colors2D[x, y] = colors1D[x + (y * texture.Width)];
                }
            }

            return colors2D;
        }
\end{DoxyCode}


Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{class_attempt__7_1_1_image_analysis_ac70a680405b76bd8b0ece8ee2a8112e8_icgraph}
\end{center}
\end{figure}


\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!Update@{Update}}
\index{Update@{Update}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{Update}]{\setlength{\rightskip}{0pt plus 5cm}override void Attempt\_\-7.ImageAnalysis.Update (
\begin{DoxyParamCaption}
\item[{GameTime}]{gameTime}
\end{DoxyParamCaption}
)}\label{class_attempt__7_1_1_image_analysis_ab597ab75ce16d1fd903b68e7df2a2c7f}


Calls the analysis methods that actually do all the work. Basically the Main function for the Image Analysis Class. 


\begin{DoxyParams}{Parameters}
{\em gameTime} & Clock Info\\
\hline
\end{DoxyParams}


Definition at line 273 of file ImageAnalysis2.cs.


\begin{DoxyCode}
        {
            currentMode = Attempt_7.SimulationMain.currentHoughMode; //Comment ou
      t for the UnitTest only

            if (this.colorArray != null)
            {
                this.trueFalseMapC = this.FindWhite(this.colorArray); // Find Whi
      te                
                this.Hough(this.trueFalseMapC); // Run the hough  
                if (this.turnIndicatorisTheta != true)
                {
                    this.trueFalseMap = this.ShowPath(this.trueFalseMapC, this.
      trueFalseMapB); // Find the path through the map   
                }

            }
            base.Update(gameTime);
        }
\end{DoxyCode}


Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{class_attempt__7_1_1_image_analysis_ab597ab75ce16d1fd903b68e7df2a2c7f_cgraph}
\end{center}
\end{figure}


\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!Update1@{Update1}}
\index{Update1@{Update1}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{Update1}]{\setlength{\rightskip}{0pt plus 5cm}void Attempt\_\-7.ImageAnalysis.Update1 (
\begin{DoxyParamCaption}
\item[{GameTime}]{gameTime1}
\end{DoxyParamCaption}
)}\label{class_attempt__7_1_1_image_analysis_a1d0bc75993df71df5d005ab3d749bb81}


Stores the texture from the robot camera in a color array before the texture is disposed. Expicitly called in the \doxyref{SimulationMain}{p.}{class_attempt__7_1_1_simulation_main} Draw method. 


\begin{DoxyParams}{Parameters}
{\em gameTime1} & Clock Information\\
\hline
\end{DoxyParams}


Definition at line 252 of file ImageAnalysis2.cs.


\begin{DoxyCode}
        {
            if (this.robotCameraView != null)
            {
                this.colorArray = this.TextureTo2DArray(this.robotCameraView, thi
      s.colorArray1D, this.colorArray);
            }
        }
\end{DoxyCode}


Here is the call graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{class_attempt__7_1_1_image_analysis_a1d0bc75993df71df5d005ab3d749bb81_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{class_attempt__7_1_1_image_analysis_a1d0bc75993df71df5d005ab3d749bb81_icgraph}
\end{center}
\end{figure}


\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!Whiteline@{Whiteline}}
\index{Whiteline@{Whiteline}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{Whiteline}]{\setlength{\rightskip}{0pt plus 5cm}bool [,] Attempt\_\-7.ImageAnalysis.Whiteline (
\begin{DoxyParamCaption}
\item[{bool}]{whitemap[,]}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a879442dce1e8ad7240a78101c31cace4}


Determines if white pixels meet the Width threshold to possibly be a line. NOT IN USE RIGHT NOW$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$$\ast$. 


\begin{DoxyParams}{Parameters}
{\em whitemap} & The TrueFalse map of whate Pixels\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A truefalse map of white pixels that met the line width requirement
\end{DoxyReturn}


Definition at line 444 of file ImageAnalysis2.cs.


\begin{DoxyCode}
        {
            int i, j, b, cnt;
            bool[,] isLine = new bool[(int)this.screenWidth, (int)this.
      screenHeight]; // Make a new array
            for (i = 0; i < this.screenWidth; ++i)
            {
                for (j = 0; j < this.screenHeight; ++j)
                {
                    if (whitemap[i, j] == true)
                    {
                        cnt = 0;
                        for (b = 0; b <= 25; b++)
                        {
                            if (j + b < this.screenHeight && whitemap[i, j + b] =
      = true)
                            {
                                cnt = cnt + 1;
                            }
                        }

                        if (cnt > 3 && cnt < 15)
                        {
                            isLine[i, j] = true;
                        }
                        else
                        {
                            isLine[i, j] = false;
                        }
                    }
                    else
                    {
                        isLine[i, j] = false;
                    }
                }
            }

            return isLine;
        }
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!accum1@{accum1}}
\index{accum1@{accum1}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{accum1}]{\setlength{\rightskip}{0pt plus 5cm}short [,] {\bf Attempt\_\-7.ImageAnalysis.accum1}\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_acb2ae3d661927b0467b5d4fdc7eded98}


Definition at line 172 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!accum2@{accum2}}
\index{accum2@{accum2}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{accum2}]{\setlength{\rightskip}{0pt plus 5cm}short [,] {\bf Attempt\_\-7.ImageAnalysis.accum2}\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_ac861772cdcfacb7ac2401079c651eb4e}


The accumlator for the hough values. Each position is a hough Bin. Each bin represents a line in Cartessian cordinates. The Accumlator is basically in polar cordinates. Theta,rho. 



Definition at line 171 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!AccumLength@{AccumLength}}
\index{AccumLength@{AccumLength}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{AccumLength}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf Attempt\_\-7.ImageAnalysis.AccumLength} = 600\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a8cdd9f3be232a5cf32006ddd52bc4ae2}


Size of the Acuumlator's lenght. Must be able to fit the largest posible value of rho. Max rho = Sqrt( ScreenHeight$^\wedge$2+ (ScreenWidth/2)$^\wedge$2), because the origin is the bottom center and the max rho is top left or right. 



Definition at line 46 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!AccumLengthOld@{AccumLengthOld}}
\index{AccumLengthOld@{AccumLengthOld}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{AccumLengthOld}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf Attempt\_\-7.ImageAnalysis.AccumLengthOld} = 810\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a75787da0f52a71c54f5f8a18d32467b8}


lenght of the hold hough accumulator 



Definition at line 51 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!blueGood@{blueGood}}
\index{blueGood@{blueGood}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{blueGood}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf Attempt\_\-7.ImageAnalysis.blueGood}\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_afdb8b1b0ef151cceeed6883a6ca955f5}


Definition at line 182 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!ClearArroundMaxDegree@{ClearArroundMaxDegree}}
\index{ClearArroundMaxDegree@{ClearArroundMaxDegree}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{ClearArroundMaxDegree}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf Attempt\_\-7.ImageAnalysis.ClearArroundMaxDegree} = 5\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_af57eb11bc470f90921bed1b60cfc9741}


Number of degrees around a maximum to clear around before searching the Accumulator again. 



Definition at line 76 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!ClearArroundMaxRho@{ClearArroundMaxRho}}
\index{ClearArroundMaxRho@{ClearArroundMaxRho}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{ClearArroundMaxRho}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf Attempt\_\-7.ImageAnalysis.ClearArroundMaxRho} = 8\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a5de31952bf3d80b7ad21aa4c0acc3092}


Number of rho values around a maximum to clear around before searching the Accumulator again. 



Definition at line 81 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!cntThreshold@{cntThreshold}}
\index{cntThreshold@{cntThreshold}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{cntThreshold}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf Attempt\_\-7.ImageAnalysis.cntThreshold} = 15\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_ae51a397ecb99b137ec6920e1329e8b6b}


Used by the smooth method. How many pixels must also be white in the area around a white pixel for it to be counted white. 



Definition at line 177 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!colorArray@{colorArray}}
\index{colorArray@{colorArray}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{colorArray}]{\setlength{\rightskip}{0pt plus 5cm}Color [,] {\bf Attempt\_\-7.ImageAnalysis.colorArray}\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a3490343b5c67fcbbdbb23257a56e4b3a}


Color Array 2D from the robot camera that is analzed. 



Definition at line 141 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!colorArray1D@{colorArray1D}}
\index{colorArray1D@{colorArray1D}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{colorArray1D}]{\setlength{\rightskip}{0pt plus 5cm}Color [$\,$] {\bf Attempt\_\-7.ImageAnalysis.colorArray1D}\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_acdb050a1334538156f7a3332ae7f332a}


Color Array 2D from the robot camera that is analzed. Can't extract informatino directly from the robot view Texture to 2D. But have to go through 1D array. 



Definition at line 146 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!count1A@{count1A}}
\index{count1A@{count1A}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{count1A}]{\setlength{\rightskip}{0pt plus 5cm}short {\bf Attempt\_\-7.ImageAnalysis.count1A} = 0\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a8fa0aaf56dde7fca58135cdc8c74575f}


These values are the incremented numbers used in the giant double \char`\"{}for-\/loops\char`\"{}. The \char`\"{}1\char`\"{} values are the for the first \char`\"{}for-\/loop\char`\"{}. 



Definition at line 151 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!count1B@{count1B}}
\index{count1B@{count1B}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{count1B}]{\setlength{\rightskip}{0pt plus 5cm}short {\bf Attempt\_\-7.ImageAnalysis.count1B} = 1\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a53eb6ffb4fdd39ce7f8f59a7358e2144}


Definition at line 151 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!count1C@{count1C}}
\index{count1C@{count1C}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{count1C}]{\setlength{\rightskip}{0pt plus 5cm}short {\bf Attempt\_\-7.ImageAnalysis.count1C} = 0\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a87af8ae466e41feca21cb200e3463bf9}


Definition at line 151 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!count1D@{count1D}}
\index{count1D@{count1D}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{count1D}]{\setlength{\rightskip}{0pt plus 5cm}short {\bf Attempt\_\-7.ImageAnalysis.count1D} = 1\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a195927d24332255e0130b0bf2791e146}


Definition at line 151 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!count1E@{count1E}}
\index{count1E@{count1E}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{count1E}]{\setlength{\rightskip}{0pt plus 5cm}short {\bf Attempt\_\-7.ImageAnalysis.count1E} = 0\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_aea1d803966f442e9699b52e196613f8c}


Definition at line 151 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!count2A@{count2A}}
\index{count2A@{count2A}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{count2A}]{\setlength{\rightskip}{0pt plus 5cm}short {\bf Attempt\_\-7.ImageAnalysis.count2A} = 0\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_ae79ba8e9b9e910edf5aded0604399f07}


These values are the incremented numbers used in the giant double \char`\"{}for-\/loops\char`\"{}. The \char`\"{}2\char`\"{} values are the for the second \char`\"{}for-\/loop\char`\"{}. 



Definition at line 156 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!count2B@{count2B}}
\index{count2B@{count2B}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{count2B}]{\setlength{\rightskip}{0pt plus 5cm}short {\bf Attempt\_\-7.ImageAnalysis.count2B} = 0\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_aa9956634aa2f4b718beb2d398b3d2b46}


Definition at line 156 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!count2C@{count2C}}
\index{count2C@{count2C}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{count2C}]{\setlength{\rightskip}{0pt plus 5cm}short {\bf Attempt\_\-7.ImageAnalysis.count2C} = 0\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a8f2510e6449b532e0a8aa7c616d8f474}


Definition at line 156 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!count2E@{count2E}}
\index{count2E@{count2E}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{count2E}]{\setlength{\rightskip}{0pt plus 5cm}short {\bf Attempt\_\-7.ImageAnalysis.count2E} = 0\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a1c9acb58142af8f283eb7958305b4337}


Definition at line 156 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!countOfNewHoughSingularities@{countOfNewHoughSingularities}}
\index{countOfNewHoughSingularities@{countOfNewHoughSingularities}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{countOfNewHoughSingularities}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf Attempt\_\-7.ImageAnalysis.countOfNewHoughSingularities} = 0\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_af6c217c696c6b6e16d8988e89d39666b}


Definition at line 194 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!countofOldHoughSingularities@{countofOldHoughSingularities}}
\index{countofOldHoughSingularities@{countofOldHoughSingularities}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{countofOldHoughSingularities}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf Attempt\_\-7.ImageAnalysis.countofOldHoughSingularities} = 0\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_ab9f59ec453ba211ebc7cd614c6ab5fab}


Definition at line 195 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!currentMode@{currentMode}}
\index{currentMode@{currentMode}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{currentMode}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf Attempt\_\-7.ImageAnalysis.currentMode} = 0\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a4b69c7da8f3962c2220e8d77fd9c51e9}


If 0 then Old mode (top left origin), if 1 then New Hough mode( bottom Center). 



Definition at line 91 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!drawAnalysis@{drawAnalysis}}
\index{drawAnalysis@{drawAnalysis}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{drawAnalysis}]{\setlength{\rightskip}{0pt plus 5cm}{\bf DrawImageAnalysis} {\bf Attempt\_\-7.ImageAnalysis.drawAnalysis}\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a20ae1fce740efa28137cde3029a1b4bf}


The drawingImageAnalysis class handles the vertex information the shows what the robot is thinking. 



Definition at line 192 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!greenGood@{greenGood}}
\index{greenGood@{greenGood}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{greenGood}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf Attempt\_\-7.ImageAnalysis.greenGood}\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a288ae76c53338d5463b05a6c978baf61}


Definition at line 182 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!houghInfo@{houghInfo}}
\index{houghInfo@{houghInfo}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{houghInfo}]{\setlength{\rightskip}{0pt plus 5cm}double [$\,$] {\bf Attempt\_\-7.ImageAnalysis.houghInfo}\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a51a11cb6235b097fb2140c32ab734521}


Stores information about lines from the hough transform. each polarRho we want to find = 7 more values to store 0=slope, 1= yInt, 2=Rho, 3=Theta, 4=Xvalue, 5=Yvalue, 6= size of the bin, 7= xTransformed value 8= yTransformedValue, 9 = distance to line Algorithm, 10= angle to line Algorithm 5 more ending values for the averages. 



Definition at line 130 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!houghLineStartandStopVectors@{houghLineStartandStopVectors}}
\index{houghLineStartandStopVectors@{houghLineStartandStopVectors}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{houghLineStartandStopVectors}]{\setlength{\rightskip}{0pt plus 5cm}Vector3 [$\,$] {\bf Attempt\_\-7.ImageAnalysis.houghLineStartandStopVectors}\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_aeb7215aa1a091fa531c07ee3aa4c03d6}


Stores vector3 locations of the beginning and end points of two lines on the screen. Was part of the old Hough system, but potientially still useful, so has not deleted. 0 = start location of line, 1 = end location ofline. 



Definition at line 136 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!middleValues@{middleValues}}
\index{middleValues@{middleValues}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{middleValues}]{\setlength{\rightskip}{0pt plus 5cm}int [$\,$] {\bf Attempt\_\-7.ImageAnalysis.middleValues}\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a6dfa6991871f29000b2e32e2a1bed121}


An array of the middle clear pixels for each row. The length of the array is the number of rows = this.screenHeight. 



Definition at line 161 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!New\_\-HOUGH\_\-MODE@{New\_\-HOUGH\_\-MODE}}
\index{New\_\-HOUGH\_\-MODE@{New\_\-HOUGH\_\-MODE}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{New\_\-HOUGH\_\-MODE}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf Attempt\_\-7.ImageAnalysis.New\_\-HOUGH\_\-MODE} = 1\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a11feb673e1bb0953762222e164cec0c7}


Definition at line 35 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!NumberofLinesToFind@{NumberofLinesToFind}}
\index{NumberofLinesToFind@{NumberofLinesToFind}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{NumberofLinesToFind}]{\setlength{\rightskip}{0pt plus 5cm}const short {\bf Attempt\_\-7.ImageAnalysis.NumberofLinesToFind} = 2\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a74cfdb396e3abe4a6f5a9ccbe4f948e2}


Number of lines the hough transform should find. 



Definition at line 40 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!OLD\_\-HOUGH\_\-MODE@{OLD\_\-HOUGH\_\-MODE}}
\index{OLD\_\-HOUGH\_\-MODE@{OLD\_\-HOUGH\_\-MODE}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{OLD\_\-HOUGH\_\-MODE}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf Attempt\_\-7.ImageAnalysis.OLD\_\-HOUGH\_\-MODE} = 0\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_aaa874c7b203d72acf483aac60d199c10}


Definition at line 34 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!redGood@{redGood}}
\index{redGood@{redGood}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{redGood}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf Attempt\_\-7.ImageAnalysis.redGood}\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_aa9e1387a4605edfe0d910284724a671a}


On a scale of 0-\/255 how high does a pixel RGB value have to be before being declared white. 



Definition at line 182 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!RhoIncrement@{RhoIncrement}}
\index{RhoIncrement@{RhoIncrement}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{RhoIncrement}]{\setlength{\rightskip}{0pt plus 5cm}const short {\bf Attempt\_\-7.ImageAnalysis.RhoIncrement} = 6\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_aade101616dd021e3cbb0501146a78835}


How big the steps are for a potiential rho values. Large values reduce computation but less acurate. 



Definition at line 61 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!robotCameraView@{robotCameraView}}
\index{robotCameraView@{robotCameraView}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{robotCameraView}]{\setlength{\rightskip}{0pt plus 5cm}Texture2D {\bf Attempt\_\-7.ImageAnalysis.robotCameraView}\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a5c675bc754b9cc7185837d234766dd04}


Texture object that represents the robot camera's current view. 



Definition at line 102 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!screenHeight@{screenHeight}}
\index{screenHeight@{screenHeight}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{screenHeight}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf Attempt\_\-7.ImageAnalysis.screenHeight}\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_af5af6f29720f9a85b1cb6a71016b7af8}


Screen Height of the image to analze. 



Definition at line 117 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!screenWidth@{screenWidth}}
\index{screenWidth@{screenWidth}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{screenWidth}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf Attempt\_\-7.ImageAnalysis.screenWidth}\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_affd258e6985c66c0a80415e3ddebb4e7}


Screen Width of the image to analze. 



Definition at line 112 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!SmoothSearchSize@{SmoothSearchSize}}
\index{SmoothSearchSize@{SmoothSearchSize}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{SmoothSearchSize}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf Attempt\_\-7.ImageAnalysis.SmoothSearchSize} = 4\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a3622f807410a6198f92490ee1964b3ff}


Used by the smooth method. Dimension of Number of pixels to look around for the smooth function. This (values$\ast$2)$^\wedge$2 = number of pixels checked. 



Definition at line 86 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!ThetaIncrement@{ThetaIncrement}}
\index{ThetaIncrement@{ThetaIncrement}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{ThetaIncrement}]{\setlength{\rightskip}{0pt plus 5cm}const short {\bf Attempt\_\-7.ImageAnalysis.ThetaIncrement} = 3\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_ae80e0958661793ecf50c1a17f1b7e9d0}


How big the steps are for a potiential theta. In degreees. Large values reduce computation but less acurate. 



Definition at line 56 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!totalWhiteCnt@{totalWhiteCnt}}
\index{totalWhiteCnt@{totalWhiteCnt}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{totalWhiteCnt}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf Attempt\_\-7.ImageAnalysis.totalWhiteCnt} = 0\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a29de7b233adab56b0b7df3464b1528ef}


Number of white pixels the \char`\"{}FindWhite\char`\"{} found. 



Definition at line 166 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!trueFalseMap@{trueFalseMap}}
\index{trueFalseMap@{trueFalseMap}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{trueFalseMap}]{\setlength{\rightskip}{0pt plus 5cm}bool [,] {\bf Attempt\_\-7.ImageAnalysis.trueFalseMap}\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_ab79ad9fb17e17983e14861ee93c3479a}


TrueFalse maps used for marking pixels either \char`\"{}good\char`\"{} or \char`\"{}bad\char`\"{}. 



Definition at line 107 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!trueFalseMapB@{trueFalseMapB}}
\index{trueFalseMapB@{trueFalseMapB}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{trueFalseMapB}]{\setlength{\rightskip}{0pt plus 5cm}bool [,] {\bf Attempt\_\-7.ImageAnalysis.trueFalseMapB}\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a88fcfe8ea8917bfe5e458a845cc2b291}


Definition at line 107 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!trueFalseMapC@{trueFalseMapC}}
\index{trueFalseMapC@{trueFalseMapC}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{trueFalseMapC}]{\setlength{\rightskip}{0pt plus 5cm}bool [,] {\bf Attempt\_\-7.ImageAnalysis.trueFalseMapC}\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_ad698ffe87469398b956a2a1c5ae2b840}


Definition at line 107 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!turnIndication@{turnIndication}}
\index{turnIndication@{turnIndication}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{turnIndication}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf Attempt\_\-7.ImageAnalysis.turnIndication} = 0\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_ace2cb703da0214a4f5565f2c619d54f8}


The turn indicator measures measures how much the analysis things the robot should go right or left. Right = positive. Left = negative. 



Definition at line 122 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!turnIndicatorisTheta@{turnIndicatorisTheta}}
\index{turnIndicatorisTheta@{turnIndicatorisTheta}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{turnIndicatorisTheta}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf Attempt\_\-7.ImageAnalysis.turnIndicatorisTheta} = false\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a9b47675bd42bc8dacf5c93bb02befd81}


If true then steering desisions will be based off the theta's of the hough transform. 



Definition at line 96 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!UpdateSquareDimForAnalysis@{UpdateSquareDimForAnalysis}}
\index{UpdateSquareDimForAnalysis@{UpdateSquareDimForAnalysis}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{UpdateSquareDimForAnalysis}]{\setlength{\rightskip}{0pt plus 5cm}const short {\bf Attempt\_\-7.ImageAnalysis.UpdateSquareDimForAnalysis} = 2\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_a228e6183baa7e0b58771ad6be4117d7f}


Inorder to make drawing go faster, not every pixels is updated every time. 1 out of This value squared is updated each pass. 



Definition at line 71 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!UpdateSquareDimForDrawing@{UpdateSquareDimForDrawing}}
\index{UpdateSquareDimForDrawing@{UpdateSquareDimForDrawing}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{UpdateSquareDimForDrawing}]{\setlength{\rightskip}{0pt plus 5cm}const short {\bf Attempt\_\-7.ImageAnalysis.UpdateSquareDimForDrawing} = 2\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_ace29e13b249b0a3d0fccd7228f47937b}


Inorder to make computations go faster, not every pixels is anylzed every time. 1 out of This value squared is analzed each pass. 



Definition at line 66 of file ImageAnalysis2.cs.

\index{Attempt\_\-7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}!whiteParam@{whiteParam}}
\index{whiteParam@{whiteParam}!Attempt_7::ImageAnalysis@{Attempt\_\-7::ImageAnalysis}}
\subsubsection[{whiteParam}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf Attempt\_\-7.ImageAnalysis.whiteParam} = 150\hspace{0.3cm}{\ttfamily  [private]}}\label{class_attempt__7_1_1_image_analysis_ab67ff7ed27c69e82b67b7d0d3b6e1fec}


Sets red\_\-good, blue\_\-good, green\_\-good to this value. 



Definition at line 187 of file ImageAnalysis2.cs.



The documentation for this class was generated from the following file:\begin{DoxyCompactItemize}
\item 
C:/Users/Anthony/Dropbox/Senior Project/attempt 7/attempt 7/attempt 7/{\bf ImageAnalysis2.cs}\end{DoxyCompactItemize}
