<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Robot Simulation: C:/Users/Anthony/Dropbox/Senior Project/attempt 7/attempt 7/attempt 7/ImageAnalysis.cs Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Robot Simulation</div>
   <div id="projectbrief">A robot simulation of the IGVC robot</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('_image_analysis_8cs.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<h1>C:/Users/Anthony/Dropbox/Senior Project/attempt 7/attempt 7/attempt 7/ImageAnalysis.cs</h1>  </div>
</div>
<div class="contents">
<a href="_image_analysis_8cs.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 
<a name="l00004"></a>00004 
<a name="l00005"></a>00005 
<a name="l00006"></a>00006 <span class="comment">//namespace Attempt_7</span>
<a name="l00007"></a>00007 <span class="comment">//{</span>
<a name="l00008"></a>00008 <span class="comment">//    using System;</span>
<a name="l00009"></a>00009 <span class="comment">//    using System.Collections.Generic;</span>
<a name="l00010"></a>00010 <span class="comment">//    using System.Diagnostics;</span>
<a name="l00011"></a>00011 <span class="comment">//    using System.IO;</span>
<a name="l00012"></a>00012 <span class="comment">//    using System.Linq;</span>
<a name="l00013"></a>00013 <span class="comment">//    using System.Timers;</span>
<a name="l00014"></a>00014 <span class="comment">//    using Microsoft.Xna.Framework;</span>
<a name="l00015"></a>00015 <span class="comment">//    using Microsoft.Xna.Framework.Audio;</span>
<a name="l00016"></a>00016 <span class="comment">//    using Microsoft.Xna.Framework.Content;</span>
<a name="l00017"></a>00017 <span class="comment">//    using Microsoft.Xna.Framework.GamerServices;</span>
<a name="l00018"></a>00018 <span class="comment">//    using Microsoft.Xna.Framework.Graphics;</span>
<a name="l00019"></a>00019 <span class="comment">//    using Microsoft.Xna.Framework.Input;</span>
<a name="l00020"></a>00020 <span class="comment">//    using Microsoft.Xna.Framework.Media;</span>
<a name="l00021"></a>00021     
<a name="l00022"></a>00022 <span class="comment">//    /// &lt;summary&gt;</span>
<a name="l00023"></a>00023 <span class="comment">//    /// &lt;para&gt;</span>
<a name="l00024"></a>00024 <span class="comment">//    /// It was easier to redure 640*480 small triangles and view then from a distance than to put a texture on the GPU</span>
<a name="l00025"></a>00025 <span class="comment">//    /// So there is a camera to view the triangels. </span>
<a name="l00026"></a>00026 <span class="comment">//    /// The class only analzes a small fraction of the pixels each time through the game loop inorder to keep the speed </span>
<a name="l00027"></a>00027 <span class="comment">//    /// high. Many of the methods have loops that cause them to only look at every X pixel each time through and then</span>
<a name="l00028"></a>00028 <span class="comment">//    /// the next time through a different set. Basically it functions like a giant double &quot;for&quot; loop.</span>
<a name="l00029"></a>00029 <span class="comment">//    /// &lt;/para&gt;    </span>
<a name="l00030"></a>00030 <span class="comment">//    /// The Image Analysis Class does the image processing of the robot view. </span>
<a name="l00031"></a>00031 <span class="comment">//    /// &lt;/summary&gt;</span>
<a name="l00032"></a>00032 <span class="comment">//    public class ImageAnalysis : Microsoft.Xna.Framework.GameComponent</span>
<a name="l00033"></a>00033 <span class="comment">//    {</span>
<a name="l00034"></a>00034 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00035"></a>00035 <span class="comment">//        /// Number of lines the hough transform should find.</span>
<a name="l00036"></a>00036 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00037"></a>00037 <span class="comment">//        private const short NumberofLinesToFind = 7;</span>
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00040"></a>00040 <span class="comment">//        /// Size of the Acuumlator&#39;s lenght. Must be able to fit the largest posible value of rho. Max rho = Sqrt( ScreenHeight^2+ (ScreenWidth/2)^2), because the origin is the bottom center and the max rho is top left or right</span>
<a name="l00041"></a>00041 <span class="comment">//        /// &lt;/summary&gt;        </span>
<a name="l00042"></a>00042 <span class="comment">//        private const int AccumLength = 600;</span>
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00045"></a>00045 <span class="comment">//        /// How big the steps are for a potiential theta. In degreees. Large values  reduce computation but less acurate.  </span>
<a name="l00046"></a>00046 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00047"></a>00047 <span class="comment">//        private const short ThetaIncrement = 5;</span>
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00050"></a>00050 <span class="comment">//        /// How big the steps are for a potiential rho values. Large values  reduce computation but less acurate.  </span>
<a name="l00051"></a>00051 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00052"></a>00052 <span class="comment">//        private const short RhoIncrement = 12;</span>
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00055"></a>00055 <span class="comment">//        /// Inorder to make computations go faster, not every pixels is anylzed every time. 1 out of This value squared is analzed each pass</span>
<a name="l00056"></a>00056 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00057"></a>00057 <span class="comment">//        private const short UpdateSquareDimForDrawing = 4;</span>
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00060"></a>00060 <span class="comment">//        /// Inorder to make drawing go faster, not every pixels is updated every time. 1 out of This value squared is updated each pass</span>
<a name="l00061"></a>00061 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00062"></a>00062 <span class="comment">//        private const short UpdateSquareDimForAnalysis = 4;</span>
<a name="l00063"></a>00063 
<a name="l00064"></a>00064 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00065"></a>00065 <span class="comment">//        /// Number of degrees around a maximum to clear around before searching the Accumulator again. </span>
<a name="l00066"></a>00066 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00067"></a>00067 <span class="comment">//        private const int ClearArroundMaxDegree = 10;</span>
<a name="l00068"></a>00068 
<a name="l00069"></a>00069 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00070"></a>00070 <span class="comment">//        /// Number of rho values around a maximum to clear around before searching the Accumulator again.</span>
<a name="l00071"></a>00071 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00072"></a>00072 <span class="comment">//        private const int ClearArroundMaxRho = 30;</span>
<a name="l00073"></a>00073 
<a name="l00074"></a>00074 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00075"></a>00075 <span class="comment">//        /// Used by the smooth method. Dimension of Number of pixels  to look around for the smooth function. This (values*2)^2 = number of pixels checked.</span>
<a name="l00076"></a>00076 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00077"></a>00077 <span class="comment">//        private const int SmoothSearchSize = 4;</span>
<a name="l00078"></a>00078 
<a name="l00079"></a>00079 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00080"></a>00080 <span class="comment">//        /// If true then steering desisions will be based off the theta&#39;s of the hough transform</span>
<a name="l00081"></a>00081 <span class="comment">//        /// &lt;/summary&gt;       </span>
<a name="l00082"></a>00082 <span class="comment">//        private bool turnIndicatorisTheta = false;</span>
<a name="l00083"></a>00083 
<a name="l00084"></a>00084         
<a name="l00085"></a>00085 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00086"></a>00086 <span class="comment">//        /// Texture object that represents the robot camera&#39;s current view</span>
<a name="l00087"></a>00087 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00088"></a>00088 <span class="comment">//        private Texture2D robotCameraView;</span>
<a name="l00089"></a>00089 
<a name="l00090"></a>00090 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00091"></a>00091 <span class="comment">//        /// TrueFalse maps used for marking pixels either &quot;good&quot; or &quot;bad&quot;</span>
<a name="l00092"></a>00092 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00093"></a>00093 <span class="comment">//        private bool[,] trueFalseMap, trueFalseMapB, trueFalseMapC;</span>
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00096"></a>00096 <span class="comment">//        /// Screen Width of the image to analze</span>
<a name="l00097"></a>00097 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00098"></a>00098 <span class="comment">//        private int screenWidth;</span>
<a name="l00099"></a>00099 
<a name="l00100"></a>00100 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00101"></a>00101 <span class="comment">//        /// Screen Height of the image to analze</span>
<a name="l00102"></a>00102 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00103"></a>00103 <span class="comment">//        private int screenHeight;</span>
<a name="l00104"></a>00104 
<a name="l00105"></a>00105 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00106"></a>00106 <span class="comment">//        /// The turn indicator measures measures how much the analysis things the robot should go right or left. Right = positive. Left = negative</span>
<a name="l00107"></a>00107 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00108"></a>00108 <span class="comment">//        private int turnIndication = 0;</span>
<a name="l00109"></a>00109 
<a name="l00110"></a>00110 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00111"></a>00111 <span class="comment">//        /// Stores information about lines from the hough transform. </span>
<a name="l00112"></a>00112 <span class="comment">//        /// values 0-13 are the old hough info</span>
<a name="l00113"></a>00113 <span class="comment">//        /// each polarRho we want to find = 7 more values to store</span>
<a name="l00114"></a>00114 <span class="comment">//        /// 0=slope, 1= yInt, 2=Rho, 3=Theta, 4=Xvalue, 5=Yvalue, 6= size of the bin</span>
<a name="l00115"></a>00115 <span class="comment">//        /// 5  more ending values for the averages</span>
<a name="l00116"></a>00116 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00117"></a>00117 <span class="comment">//        private double[] houghInfo;        </span>
<a name="l00118"></a>00118 
<a name="l00119"></a>00119 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00120"></a>00120 <span class="comment">//        /// Stores 4 vector3 locations of the beginning and end points of two lines on the screen. Was part of the old Hough system, but potientially still useful, so has not deleted.</span>
<a name="l00121"></a>00121 <span class="comment">//        /// 0 = start location of first line, 1 = end location of first line, 2 = start location of second line, 3 = end location of second line</span>
<a name="l00122"></a>00122 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00123"></a>00123 <span class="comment">//        private List&lt;Vector3&gt; houghLineStartandStopVectors;       </span>
<a name="l00124"></a>00124 
<a name="l00125"></a>00125 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00126"></a>00126 <span class="comment">//        /// Color Array 2D from the robot camera that is analzed. </span>
<a name="l00127"></a>00127 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00128"></a>00128 <span class="comment">//        private Color[,] colorArray;</span>
<a name="l00129"></a>00129 
<a name="l00130"></a>00130 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00131"></a>00131 <span class="comment">//        /// Color Array 2D from the robot camera that is analzed. Can&#39;t extract informatino directly from the robot view Texture to 2D. But have to go through 1D array.</span>
<a name="l00132"></a>00132 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00133"></a>00133 <span class="comment">//        private Color[] colorArray1D;       </span>
<a name="l00134"></a>00134 
<a name="l00135"></a>00135 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00136"></a>00136 <span class="comment">//        /// These values are the incremented numbers used in the giant double &quot;for-loops&quot;. The &quot;1&quot; values are the for the first &quot;for-loop&quot;</span>
<a name="l00137"></a>00137 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00138"></a>00138 <span class="comment">//        private short count1A = 0, count1B = 1, count1C = 0, count1D = 1, count1E = 0;</span>
<a name="l00139"></a>00139 
<a name="l00140"></a>00140 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00141"></a>00141 <span class="comment">//        /// These values are the incremented numbers used in the giant double &quot;for-loops&quot;. The &quot;2&quot; values are the for the second &quot;for-loop&quot;</span>
<a name="l00142"></a>00142 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00143"></a>00143 <span class="comment">//        private short count2A = 0, count2B = 0, count2C = 0, count2E = 0;</span>
<a name="l00144"></a>00144 
<a name="l00145"></a>00145 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00146"></a>00146 <span class="comment">//        /// An array of the middle clear pixels for each row. The length of the array is the number of rows = this.screenHeight.</span>
<a name="l00147"></a>00147 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00148"></a>00148 <span class="comment">//        private int[] middleValues;</span>
<a name="l00149"></a>00149 
<a name="l00150"></a>00150 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00151"></a>00151 <span class="comment">//        /// Number of white pixels the &quot;FindWhite&quot; found</span>
<a name="l00152"></a>00152 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00153"></a>00153 <span class="comment">//        private int totalWhiteCnt = 0;</span>
<a name="l00154"></a>00154 
<a name="l00155"></a>00155 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00156"></a>00156 <span class="comment">//        /// The accumlator for the hough values. Each position is a hough Bin. Each bin represents a line in Cartessian cordinates. The Accumlator is basically in polar cordinates. Theta,rho</span>
<a name="l00157"></a>00157 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00158"></a>00158 <span class="comment">//        private short[,] accum2;</span>
<a name="l00159"></a>00159        
<a name="l00160"></a>00160 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00161"></a>00161 <span class="comment">//        /// Used by the smooth method. How many pixels must also be white in the area around a white pixel for it to be counted white. </span>
<a name="l00162"></a>00162 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00163"></a>00163 <span class="comment">//        private int cntThreshold = 15;</span>
<a name="l00164"></a>00164 
<a name="l00165"></a>00165 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00166"></a>00166 <span class="comment">//        /// On a scale of 0-255 how high does a pixel RGB value have to be before being declared white. </span>
<a name="l00167"></a>00167 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00168"></a>00168 <span class="comment">//        private int redGood, blueGood, greenGood;</span>
<a name="l00169"></a>00169 
<a name="l00170"></a>00170 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00171"></a>00171 <span class="comment">//        /// Sets red_good, blue_good, green_good to this value. </span>
<a name="l00172"></a>00172 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00173"></a>00173 <span class="comment">//        private int whiteParam = 150;</span>
<a name="l00174"></a>00174 
<a name="l00175"></a>00175 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00176"></a>00176 <span class="comment">//        /// The drawingImageAnalysis class handles the vertex information the shows what the robot is thinking</span>
<a name="l00177"></a>00177 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00178"></a>00178 <span class="comment">//        DrawImageAnalysis drawAnalysis;        </span>
<a name="l00179"></a>00179 
<a name="l00180"></a>00180 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00181"></a>00181 <span class="comment">//        /// Initializes a new instance of the ImageAnalysis class.</span>
<a name="l00182"></a>00182 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00183"></a>00183 <span class="comment">//        /// &lt;param name=&quot;game&quot;&gt;The game associated with the class&lt;/param&gt;</span>
<a name="l00184"></a>00184 <span class="comment">//        /// &lt;param name=&quot;screenSize&quot;&gt;The size of the sceen to analze&lt;/param&gt;</span>
<a name="l00185"></a>00185 <span class="comment">//        /// &lt;param name=&quot;viewPortList1&quot;&gt;A list of the view ports&lt;/param&gt;</span>
<a name="l00186"></a>00186 <span class="comment">//        public ImageAnalysis(Game game, Vector2 screenSize, List&lt;Viewport&gt; viewPortList1)</span>
<a name="l00187"></a>00187 <span class="comment">//            : base(game)</span>
<a name="l00188"></a>00188 <span class="comment">//        {           </span>
<a name="l00189"></a>00189 <span class="comment">//            this.screenWidth = (int)screenSize.X;</span>
<a name="l00190"></a>00190 <span class="comment">//            this.screenHeight = (int)screenSize.Y;</span>
<a name="l00191"></a>00191 
<a name="l00192"></a>00192 <span class="comment">//            //Creates the image drawing analysis object.</span>
<a name="l00193"></a>00193 <span class="comment">//            drawAnalysis = new DrawImageAnalysis(game, screenWidth, screenHeight, UpdateSquareDimForDrawing, UpdateSquareDimForAnalysis, NumberofLinesToFind, ThetaIncrement, RhoIncrement, viewPortList1,this );</span>
<a name="l00194"></a>00194 <span class="comment">//            drawAnalysis.DrawOrder = game.Components.Count;</span>
<a name="l00195"></a>00195 <span class="comment">//            Game.Components.Add(drawAnalysis);</span>
<a name="l00196"></a>00196 <span class="comment">//        }</span>
<a name="l00197"></a>00197 
<a name="l00198"></a>00198 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00199"></a>00199 <span class="comment">//        /// Called when the class is initialized. Creates many of the arrays and sets many of the values. </span>
<a name="l00200"></a>00200 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00201"></a>00201 <span class="comment">//        public override void Initialize()</span>
<a name="l00202"></a>00202 <span class="comment">//        {</span>
<a name="l00203"></a>00203 <span class="comment">//            // Create the arrays needed. Building them now will save CPU later. </span>
<a name="l00204"></a>00204 <span class="comment">//            this.trueFalseMap = new bool[this.screenWidth, this.screenHeight];</span>
<a name="l00205"></a>00205 <span class="comment">//            this.trueFalseMapB = new bool[this.screenWidth, this.screenHeight];</span>
<a name="l00206"></a>00206 <span class="comment">//            this.trueFalseMapC = new bool[this.screenWidth, this.screenHeight];</span>
<a name="l00207"></a>00207 
<a name="l00208"></a>00208 <span class="comment">//            this.accum2 = new short[180 / ThetaIncrement, AccumLength / RhoIncrement]; // Build the accumlator array. Make is smaller or shorter based on the size of the rho and theta increments</span>
<a name="l00209"></a>00209 <span class="comment">//            this.colorArray1D = new Color[this.screenWidth * this.screenHeight]; // Create a 1D array of color</span>
<a name="l00210"></a>00210 <span class="comment">//            this.colorArray = new Color[this.screenWidth, this.screenHeight]; // Create a 2D array of color</span>
<a name="l00211"></a>00211 
<a name="l00212"></a>00212 <span class="comment">//            this.houghInfo = new double[(14 + 7 + 5) * NumberofLinesToFind]; // Make the array to store hough information. Must be double so that slopes which are fractions can be stored</span>
<a name="l00213"></a>00213 
<a name="l00214"></a>00214 <span class="comment">//            // Set the color thresholds</span>
<a name="l00215"></a>00215 <span class="comment">//            this.redGood = this.whiteParam;</span>
<a name="l00216"></a>00216 <span class="comment">//            this.blueGood = this.whiteParam;</span>
<a name="l00217"></a>00217 <span class="comment">//            this.greenGood = this.whiteParam;</span>
<a name="l00218"></a>00218 
<a name="l00219"></a>00219 <span class="comment">//            this.houghLineStartandStopVectors = new List&lt;Vector3&gt;();</span>
<a name="l00220"></a>00220 <span class="comment">//            for (int i = 0; i &lt; 4; i++)</span>
<a name="l00221"></a>00221 <span class="comment">//            {</span>
<a name="l00222"></a>00222 <span class="comment">//                this.houghLineStartandStopVectors.Add(Vector3.Zero);</span>
<a name="l00223"></a>00223 <span class="comment">//            }          </span>
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 <span class="comment">//            this.middleValues = new int[this.screenHeight]; // Steering desisions are based off the average middle clear value for each row</span>
<a name="l00226"></a>00226 
<a name="l00227"></a>00227 <span class="comment">//            base.Initialize();</span>
<a name="l00228"></a>00228 <span class="comment">//        }</span>
<a name="l00229"></a>00229 
<a name="l00230"></a>00230 <span class="comment">//        /// &lt;summary&gt; </span>
<a name="l00231"></a>00231 <span class="comment">//        /// Stores the texture from the robot camera in a color array before the texture is disposed. Expicitly called in the SimulationMain Draw method</span>
<a name="l00232"></a>00232 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00233"></a>00233 <span class="comment">//        /// &lt;param name=&quot;gameTime1&quot;&gt;Clock Information&lt;/param&gt;</span>
<a name="l00234"></a>00234 <span class="comment">//        public void Update1(GameTime gameTime1)</span>
<a name="l00235"></a>00235 <span class="comment">//        {</span>
<a name="l00236"></a>00236 <span class="comment">//            if (this.robotCameraView != null)</span>
<a name="l00237"></a>00237 <span class="comment">//            {</span>
<a name="l00238"></a>00238 <span class="comment">//                this.colorArray = this.TextureTo2DArray(this.robotCameraView, this.colorArray1D, this.colorArray);</span>
<a name="l00239"></a>00239 <span class="comment">//            }</span>
<a name="l00240"></a>00240 <span class="comment">//        }</span>
<a name="l00241"></a>00241 
<a name="l00242"></a>00242 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00243"></a>00243 <span class="comment">//        /// Takes a  2D renderTarget/Texture and sets it as the image to analze. Explicitly called in the SimulationMain Draw Method.</span>
<a name="l00244"></a>00244 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00245"></a>00245 <span class="comment">//        /// &lt;param name=&quot;text&quot;&gt;The texture to analze. &lt;/param&gt;</span>
<a name="l00246"></a>00246 <span class="comment">//        public void SetRobotCameraView(Texture2D text)</span>
<a name="l00247"></a>00247 <span class="comment">//        {</span>
<a name="l00248"></a>00248 <span class="comment">//            this.robotCameraView = text;</span>
<a name="l00249"></a>00249 <span class="comment">//        }</span>
<a name="l00250"></a>00250 
<a name="l00251"></a>00251 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00252"></a>00252 <span class="comment">//        /// Calls the analysis methods that actually do all the work. Basically the Main function for the Image Analysis Class</span>
<a name="l00253"></a>00253 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00254"></a>00254 <span class="comment">//        /// &lt;param name=&quot;gameTime&quot;&gt;Clock Info&lt;/param&gt;</span>
<a name="l00255"></a>00255 <span class="comment">//        public override void Update(GameTime gameTime)</span>
<a name="l00256"></a>00256 <span class="comment">//        {</span>
<a name="l00257"></a>00257 <span class="comment">//            if (this.colorArray != null)</span>
<a name="l00258"></a>00258 <span class="comment">//            {</span>
<a name="l00259"></a>00259 <span class="comment">//                this.trueFalseMapC = this.FindWhite(this.colorArray); // Find White                </span>
<a name="l00260"></a>00260 <span class="comment">//                this.Hough(this.trueFalseMapC); // Run the hough  </span>
<a name="l00261"></a>00261 <span class="comment">//                if (this.turnIndicatorisTheta != true)</span>
<a name="l00262"></a>00262 <span class="comment">//                {</span>
<a name="l00263"></a>00263 <span class="comment">//                    this.trueFalseMap = this.ShowPath(this.trueFalseMapC, this.trueFalseMapB); // Find the path through the map   </span>
<a name="l00264"></a>00264 <span class="comment">//                }</span>
<a name="l00265"></a>00265                
<a name="l00266"></a>00266 <span class="comment">//                ////UpdateColorArrayto3DRectangle(colorArray, vertexArray);</span>
<a name="l00267"></a>00267 <span class="comment">//            }</span>
<a name="l00268"></a>00268 <span class="comment">//            base.Update(gameTime);</span>
<a name="l00269"></a>00269 <span class="comment">//        }</span>
<a name="l00270"></a>00270 <span class="comment">//        public int GetWhiteCount()</span>
<a name="l00271"></a>00271 <span class="comment">//        {</span>
<a name="l00272"></a>00272 <span class="comment">//            return totalWhiteCnt;</span>
<a name="l00273"></a>00273 <span class="comment">//        }</span>
<a name="l00274"></a>00274 
<a name="l00275"></a>00275 <span class="comment">//        public double[] GetHoughInfo()</span>
<a name="l00276"></a>00276 <span class="comment">//        {</span>
<a name="l00277"></a>00277 <span class="comment">//            return houghInfo;</span>
<a name="l00278"></a>00278 <span class="comment">//        }</span>
<a name="l00279"></a>00279 
<a name="l00280"></a>00280 <span class="comment">//        public bool[,] GetTrueFalseMaptoDraw()</span>
<a name="l00281"></a>00281 <span class="comment">//        {</span>
<a name="l00282"></a>00282 <span class="comment">//            return trueFalseMapC;</span>
<a name="l00283"></a>00283 <span class="comment">//        }</span>
<a name="l00284"></a>00284 
<a name="l00285"></a>00285 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00286"></a>00286 <span class="comment">//        /// Allows the SimulationMain to get the turnIndicator</span>
<a name="l00287"></a>00287 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00288"></a>00288 <span class="comment">//        /// &lt;returns&gt;The turn Indicator&lt;/returns&gt;</span>
<a name="l00289"></a>00289 <span class="comment">//        public int GetTurnIndicator()</span>
<a name="l00290"></a>00290 <span class="comment">//        {</span>
<a name="l00291"></a>00291 <span class="comment">//            return this.turnIndication;</span>
<a name="l00292"></a>00292 <span class="comment">//        }</span>
<a name="l00293"></a>00293        
<a name="l00294"></a>00294 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00295"></a>00295 <span class="comment">//        /// Takes a texture and makes it into a 2D color array. Passing in the arrays is faster than trying to build it each time. </span>
<a name="l00296"></a>00296 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00297"></a>00297 <span class="comment">//        /// &lt;param name=&quot;texture&quot;&gt;Texture to extract color information&lt;/param&gt;</span>
<a name="l00298"></a>00298 <span class="comment">//        /// &lt;param name=&quot;colors1D&quot;&gt;1D array needed for the extraction&lt;/param&gt;</span>
<a name="l00299"></a>00299 <span class="comment">//        /// &lt;param name=&quot;colors2D&quot;&gt;2D array that will be returned&lt;/param&gt;</span>
<a name="l00300"></a>00300 <span class="comment">//        /// &lt;returns&gt;The 2D color array of the texture color information&lt;/returns&gt;</span>
<a name="l00301"></a>00301 <span class="comment">//        private Color[,] TextureTo2DArray(Texture2D texture, Color[] colors1D, Color[,] colors2D)</span>
<a name="l00302"></a>00302 <span class="comment">//        {</span>
<a name="l00303"></a>00303 <span class="comment">//            texture.GetData(colors1D);</span>
<a name="l00304"></a>00304 <span class="comment">//            for (int x = 0; x &lt; texture.Width; x++)</span>
<a name="l00305"></a>00305 <span class="comment">//            {</span>
<a name="l00306"></a>00306 <span class="comment">//                for (int y = 0; y &lt; texture.Height; y++)</span>
<a name="l00307"></a>00307 <span class="comment">//                {</span>
<a name="l00308"></a>00308 <span class="comment">//                    colors2D[x, y] = colors1D[x + (y * texture.Width)];</span>
<a name="l00309"></a>00309 <span class="comment">//                }</span>
<a name="l00310"></a>00310 <span class="comment">//            }</span>
<a name="l00311"></a>00311 
<a name="l00312"></a>00312 <span class="comment">//            return colors2D;</span>
<a name="l00313"></a>00313 <span class="comment">//        }</span>
<a name="l00314"></a>00314         
<a name="l00315"></a>00315 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00316"></a>00316 <span class="comment">//        /// Takes a 2D color array and finds the pixels that are &quot;white&quot;</span>
<a name="l00317"></a>00317 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00318"></a>00318 <span class="comment">//        /// &lt;param name=&quot;colorArray1&quot;&gt;The color array to find white in.&lt;/param&gt;</span>
<a name="l00319"></a>00319 <span class="comment">//        /// &lt;returns&gt;The TrueFalse bool map of white pixels. True  = white, False = not white. &lt;/returns&gt;</span>
<a name="l00320"></a>00320 <span class="comment">//        private bool[,] FindWhite(Color[,] colorArray1)</span>
<a name="l00321"></a>00321 <span class="comment">//        {</span>
<a name="l00322"></a>00322 <span class="comment">//            // True = bad, False = good.</span>
<a name="l00323"></a>00323 <span class="comment">//            this.totalWhiteCnt = 0;</span>
<a name="l00324"></a>00324 <span class="comment">//            int i, j;</span>
<a name="l00325"></a>00325 <span class="comment">//            bool[,] trueFalseMap = new bool[colorArray1.GetLength(0), colorArray1.GetLength(1)]; // Create the bool map.</span>
<a name="l00326"></a>00326 
<a name="l00327"></a>00327 <span class="comment">//            for (i = 0; i &lt; this.screenWidth; ++i)</span>
<a name="l00328"></a>00328 <span class="comment">//            {</span>
<a name="l00329"></a>00329 <span class="comment">//                for (j = 0; j &lt; this.screenHeight; ++j)</span>
<a name="l00330"></a>00330 <span class="comment">//                {</span>
<a name="l00331"></a>00331 <span class="comment">//                    // If above the thresholds. </span>
<a name="l00332"></a>00332 <span class="comment">//                    if ((colorArray1[i, j].R &gt; this.redGood)</span>
<a name="l00333"></a>00333 <span class="comment">//                        &amp;&amp; (colorArray1[i, j].G &gt; this.greenGood)</span>
<a name="l00334"></a>00334 <span class="comment">//                        &amp;&amp; (colorArray1[i, j].B &gt; this.blueGood))</span>
<a name="l00335"></a>00335 <span class="comment">//                    {</span>
<a name="l00336"></a>00336 <span class="comment">//                        trueFalseMap[i, j] = true;</span>
<a name="l00337"></a>00337 <span class="comment">//                        this.totalWhiteCnt++;</span>
<a name="l00338"></a>00338 <span class="comment">//                    }</span>
<a name="l00339"></a>00339 <span class="comment">//                    else</span>
<a name="l00340"></a>00340 <span class="comment">//                    {</span>
<a name="l00341"></a>00341 <span class="comment">//                        trueFalseMap[i, j] = false;</span>
<a name="l00342"></a>00342 <span class="comment">//                    }</span>
<a name="l00343"></a>00343 <span class="comment">//                }</span>
<a name="l00344"></a>00344 <span class="comment">//            }</span>
<a name="l00345"></a>00345 
<a name="l00346"></a>00346 <span class="comment">//            return trueFalseMap;</span>
<a name="l00347"></a>00347 <span class="comment">//        }</span>
<a name="l00348"></a>00348 
<a name="l00349"></a>00349 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00350"></a>00350 <span class="comment">//        ///  Determines if white pixels meet the Width threshold to possibly be a line. </span>
<a name="l00351"></a>00351 <span class="comment">//        ///  *******************NOT IN USE RIGHT NOW********************</span>
<a name="l00352"></a>00352 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00353"></a>00353 <span class="comment">//        /// &lt;param name=&quot;whitemap&quot;&gt;The TrueFalse map of whate Pixels&lt;/param&gt;</span>
<a name="l00354"></a>00354 <span class="comment">//        /// &lt;returns&gt; A truefalse map of white pixels that met the line width requirement&lt;/returns&gt;</span>
<a name="l00355"></a>00355 <span class="comment">//        private bool[,] Whiteline(bool[,] whitemap)</span>
<a name="l00356"></a>00356 <span class="comment">//        {</span>
<a name="l00357"></a>00357 <span class="comment">//            int i, j, b, cnt;</span>
<a name="l00358"></a>00358 <span class="comment">//            bool[,] isLine = new bool[(int)this.screenWidth, (int)this.screenHeight]; // Make a new array</span>
<a name="l00359"></a>00359 <span class="comment">//            for (i = 0; i &lt; this.screenWidth; ++i)</span>
<a name="l00360"></a>00360 <span class="comment">//            {</span>
<a name="l00361"></a>00361 <span class="comment">//                for (j = 0; j &lt; this.screenHeight; ++j)</span>
<a name="l00362"></a>00362 <span class="comment">//                {</span>
<a name="l00363"></a>00363 <span class="comment">//                    if (whitemap[i, j] == true)</span>
<a name="l00364"></a>00364 <span class="comment">//                    {</span>
<a name="l00365"></a>00365 <span class="comment">//                        cnt = 0;</span>
<a name="l00366"></a>00366 <span class="comment">//                        for (b = 0; b &lt;= 25; b++)</span>
<a name="l00367"></a>00367 <span class="comment">//                        {</span>
<a name="l00368"></a>00368 <span class="comment">//                            if (j + b &lt; this.screenHeight &amp;&amp; whitemap[i, j + b] == true)</span>
<a name="l00369"></a>00369 <span class="comment">//                            {</span>
<a name="l00370"></a>00370 <span class="comment">//                                cnt = cnt + 1;</span>
<a name="l00371"></a>00371 <span class="comment">//                            }</span>
<a name="l00372"></a>00372 <span class="comment">//                        }</span>
<a name="l00373"></a>00373 
<a name="l00374"></a>00374 <span class="comment">//                        if (cnt &gt; 3 &amp;&amp; cnt &lt; 15)</span>
<a name="l00375"></a>00375 <span class="comment">//                        {</span>
<a name="l00376"></a>00376 <span class="comment">//                            isLine[i, j] = true;</span>
<a name="l00377"></a>00377 <span class="comment">//                        }</span>
<a name="l00378"></a>00378 <span class="comment">//                        else</span>
<a name="l00379"></a>00379 <span class="comment">//                        {</span>
<a name="l00380"></a>00380 <span class="comment">//                            isLine[i, j] = false;</span>
<a name="l00381"></a>00381 <span class="comment">//                        }</span>
<a name="l00382"></a>00382 <span class="comment">//                    }</span>
<a name="l00383"></a>00383 <span class="comment">//                    else</span>
<a name="l00384"></a>00384 <span class="comment">//                    {</span>
<a name="l00385"></a>00385 <span class="comment">//                        isLine[i, j] = false;</span>
<a name="l00386"></a>00386 <span class="comment">//                    }</span>
<a name="l00387"></a>00387 <span class="comment">//                }</span>
<a name="l00388"></a>00388 <span class="comment">//            }</span>
<a name="l00389"></a>00389 
<a name="l00390"></a>00390 <span class="comment">//            return isLine;</span>
<a name="l00391"></a>00391 <span class="comment">//        }</span>
<a name="l00392"></a>00392 
<a name="l00393"></a>00393 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00394"></a>00394 <span class="comment">//        /// Takes a truefalse map and for each pixel checks the other pixels around it to see if they are also white. If the number of pixels arround it that are also white is above a threshold then keep that pixel white. Meant to reduce noise in the picture.</span>
<a name="l00395"></a>00395 <span class="comment">//        /// *******************NOT IN USE RIGHT NOW********************</span>
<a name="l00396"></a>00396 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00397"></a>00397 <span class="comment">//        /// &lt;param name=&quot;original&quot;&gt;The raw truefalse map of whie pixels.&lt;/param&gt;</span>
<a name="l00398"></a>00398 <span class="comment">//        /// &lt;param name=&quot;final&quot;&gt;The trueFalse map to modify&lt;/param&gt;</span>
<a name="l00399"></a>00399 <span class="comment">//        /// &lt;returns&gt;The truefalse map of pixels that met the threshold requirements. &lt;/returns&gt;</span>
<a name="l00400"></a>00400 <span class="comment">//        private bool[,] Smooth(bool[,] original, bool[,] final)</span>
<a name="l00401"></a>00401 <span class="comment">//        {</span>
<a name="l00402"></a>00402 <span class="comment">//            int cnt;</span>
<a name="l00403"></a>00403 <span class="comment">//            for (int i = this.count1B; i &lt; this.screenWidth; i += UpdateSquareDimForAnalysis)</span>
<a name="l00404"></a>00404 <span class="comment">//            {</span>
<a name="l00405"></a>00405 <span class="comment">//                for (int j = this.count2B; j &lt; this.screenHeight; j += UpdateSquareDimForAnalysis)</span>
<a name="l00406"></a>00406 <span class="comment">//                {</span>
<a name="l00407"></a>00407 <span class="comment">//                    if (original[i, j] == true)</span>
<a name="l00408"></a>00408 <span class="comment">//                    {</span>
<a name="l00409"></a>00409 <span class="comment">//                        cnt = 0;</span>
<a name="l00410"></a>00410 <span class="comment">//                        for (int a = -SmoothSearchSize; a &lt;= SmoothSearchSize; a++)</span>
<a name="l00411"></a>00411 <span class="comment">//                        {</span>
<a name="l00412"></a>00412 <span class="comment">//                            for (int b = -SmoothSearchSize; b &lt;= SmoothSearchSize; b++)</span>
<a name="l00413"></a>00413 <span class="comment">//                            {</span>
<a name="l00414"></a>00414 <span class="comment">//                                if (i + a &gt; -1 &amp;&amp; i + a &lt; this.screenWidth &amp;&amp; j + b &gt; -1 &amp;&amp; j + b &lt; this.screenHeight)</span>
<a name="l00415"></a>00415 <span class="comment">//                                {</span>
<a name="l00416"></a>00416 <span class="comment">//                                    if (original[i + a, j + b] == true)</span>
<a name="l00417"></a>00417 <span class="comment">//                                    {</span>
<a name="l00418"></a>00418 <span class="comment">//                                        cnt = cnt + 1;</span>
<a name="l00419"></a>00419 <span class="comment">//                                    }</span>
<a name="l00420"></a>00420 <span class="comment">//                                }</span>
<a name="l00421"></a>00421 <span class="comment">//                            }</span>
<a name="l00422"></a>00422 <span class="comment">//                        }</span>
<a name="l00423"></a>00423 
<a name="l00424"></a>00424 <span class="comment">//                        if (cnt &gt; this.cntThreshold)</span>
<a name="l00425"></a>00425 <span class="comment">//                        {</span>
<a name="l00426"></a>00426 <span class="comment">//                            final[i, j] = true;</span>
<a name="l00427"></a>00427 <span class="comment">//                        }</span>
<a name="l00428"></a>00428 <span class="comment">//                        else</span>
<a name="l00429"></a>00429 <span class="comment">//                        {</span>
<a name="l00430"></a>00430 <span class="comment">//                            final[i, j] = false;</span>
<a name="l00431"></a>00431 <span class="comment">//                        }</span>
<a name="l00432"></a>00432 <span class="comment">//                    }</span>
<a name="l00433"></a>00433 <span class="comment">//                    else</span>
<a name="l00434"></a>00434 <span class="comment">//                    {</span>
<a name="l00435"></a>00435 <span class="comment">//                        final[i, j] = false;</span>
<a name="l00436"></a>00436 <span class="comment">//                    }</span>
<a name="l00437"></a>00437 <span class="comment">//                }</span>
<a name="l00438"></a>00438 <span class="comment">//            }</span>
<a name="l00439"></a>00439 
<a name="l00440"></a>00440 <span class="comment">//            this.count1B++;</span>
<a name="l00441"></a>00441 <span class="comment">//            if (this.count1B == UpdateSquareDimForDrawing)</span>
<a name="l00442"></a>00442 <span class="comment">//            {</span>
<a name="l00443"></a>00443 <span class="comment">//                this.count1B = 0;</span>
<a name="l00444"></a>00444 <span class="comment">//                this.count2B++;</span>
<a name="l00445"></a>00445 <span class="comment">//                if (this.count2B == UpdateSquareDimForDrawing)</span>
<a name="l00446"></a>00446 <span class="comment">//                {</span>
<a name="l00447"></a>00447 <span class="comment">//                    this.count2B = 0;</span>
<a name="l00448"></a>00448 <span class="comment">//                }</span>
<a name="l00449"></a>00449 <span class="comment">//            }</span>
<a name="l00450"></a>00450 
<a name="l00451"></a>00451 <span class="comment">//            return final;</span>
<a name="l00452"></a>00452 <span class="comment">//        }</span>
<a name="l00453"></a>00453 
<a name="l00454"></a>00454 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00455"></a>00455 <span class="comment">//        /// Find a path through the map to go through and return it as a bool map, also set the turn indicator.</span>
<a name="l00456"></a>00456 <span class="comment">//        /// Based off the reactiveNavigation from the old robot code. </span>
<a name="l00457"></a>00457 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00458"></a>00458 <span class="comment">//        /// &lt;param name=&quot;blocked&quot;&gt;The trueFalse map of pixels that are blocked.&lt;/param&gt;</span>
<a name="l00459"></a>00459 <span class="comment">//        /// &lt;param name=&quot;clearPath&quot;&gt;Blank. This map will be turned.&lt;/param&gt;</span>
<a name="l00460"></a>00460 <span class="comment">//        /// &lt;returns&gt;The trueFalse map of a clear path.&lt;/returns&gt;</span>
<a name="l00461"></a>00461 <span class="comment">//        private bool[,] ShowPath(bool[,] blocked, bool[,] clearPath)</span>
<a name="l00462"></a>00462 <span class="comment">//        {</span>
<a name="l00463"></a>00463 <span class="comment">//            int lastRightX = this.screenWidth, lastLeftX = 0;</span>
<a name="l00464"></a>00464 <span class="comment">//            int leftX, rightX;</span>
<a name="l00465"></a>00465 <span class="comment">//            int sum = 0;</span>
<a name="l00466"></a>00466 
<a name="l00467"></a>00467 <span class="comment">//            for (int rowNumber = this.screenHeight - this.count1D - 1; rowNumber &gt; 0; rowNumber -= UpdateSquareDimForAnalysis)</span>
<a name="l00468"></a>00468 <span class="comment">//            {</span>
<a name="l00469"></a>00469 <span class="comment">//                // Start in the middle</span>
<a name="l00470"></a>00470 <span class="comment">//                leftX = (int)((lastLeftX + lastRightX) / 2);</span>
<a name="l00471"></a>00471 
<a name="l00472"></a>00472 <span class="comment">//                // Search starting in the middle and bottom of picture and go left (i.e. subtract) for a blocked pixel</span>
<a name="l00473"></a>00473 <span class="comment">//                while (leftX &gt; lastLeftX &amp;&amp; blocked[leftX, rowNumber] == false)</span>
<a name="l00474"></a>00474 <span class="comment">//                {</span>
<a name="l00475"></a>00475 <span class="comment">//                    clearPath[leftX, rowNumber] = true;</span>
<a name="l00476"></a>00476 <span class="comment">//                    leftX--;</span>
<a name="l00477"></a>00477 <span class="comment">//                }</span>
<a name="l00478"></a>00478 
<a name="l00479"></a>00479 <span class="comment">//                // Start in the middle and bottome go right </span>
<a name="l00480"></a>00480 <span class="comment">//                rightX = (int)((lastLeftX + lastRightX) / 2);</span>
<a name="l00481"></a>00481 
<a name="l00482"></a>00482 <span class="comment">//                while (rightX &lt; lastRightX &amp;&amp; blocked[rightX, rowNumber] == false)</span>
<a name="l00483"></a>00483 <span class="comment">//                {</span>
<a name="l00484"></a>00484 <span class="comment">//                    clearPath[rightX, rowNumber] = true;</span>
<a name="l00485"></a>00485 <span class="comment">//                    rightX++;</span>
<a name="l00486"></a>00486 <span class="comment">//                }</span>
<a name="l00487"></a>00487 
<a name="l00488"></a>00488 <span class="comment">//                lastLeftX = leftX;</span>
<a name="l00489"></a>00489 <span class="comment">//                lastRightX = rightX;</span>
<a name="l00490"></a>00490 <span class="comment">//                sum += (int)((lastLeftX + lastRightX) / 2);</span>
<a name="l00491"></a>00491 <span class="comment">//            }</span>
<a name="l00492"></a>00492 
<a name="l00493"></a>00493 <span class="comment">//            this.count1D++;</span>
<a name="l00494"></a>00494 <span class="comment">//            if (this.count1D == UpdateSquareDimForAnalysis)</span>
<a name="l00495"></a>00495 <span class="comment">//            {</span>
<a name="l00496"></a>00496 <span class="comment">//                this.count1D = 0;</span>
<a name="l00497"></a>00497 <span class="comment">//            }</span>
<a name="l00498"></a>00498 
<a name="l00499"></a>00499 <span class="comment">//            // Find the average middle pixels for each row and set the turn indicator based on this value. </span>
<a name="l00500"></a>00500 <span class="comment">//            this.turnIndication = ((sum * UpdateSquareDimForAnalysis) / this.screenHeight) - (this.screenWidth / 2);</span>
<a name="l00501"></a>00501 <span class="comment">//            return clearPath;</span>
<a name="l00502"></a>00502 <span class="comment">//        }</span>
<a name="l00503"></a>00503 
<a name="l00504"></a>00504 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00505"></a>00505 <span class="comment">//        /// Finds Max value in Hough. Store information about that max.</span>
<a name="l00506"></a>00506 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00507"></a>00507 <span class="comment">//        /// &lt;param name=&quot;accumToAnalze&quot;&gt;The accumlator of bins we want to search&lt;/param&gt;</span>
<a name="l00508"></a>00508 <span class="comment">//        /// &lt;param name=&quot;thetaIncrement&quot;&gt;How large is the quantitization of the theta values. &lt;/param&gt;</span>
<a name="l00509"></a>00509 <span class="comment">//        /// &lt;param name=&quot;startIndexOfStoringHoughInfoList&quot;&gt;What value in the Array &#39;HoughInfo&#39; should we start storing information.&lt;/param&gt;</span>
<a name="l00510"></a>00510 <span class="comment">//        private void FindMaxInAccumArrayOfHough(short[,] accumToAnalze, short thetaIncrement, short startIndexOfStoringHoughInfoList)</span>
<a name="l00511"></a>00511 <span class="comment">//        {</span>
<a name="l00512"></a>00512 <span class="comment">//            int maxTheta = 1;</span>
<a name="l00513"></a>00513 <span class="comment">//            int maxRho = 1;</span>
<a name="l00514"></a>00514 <span class="comment">//            int maxAccum = 1;</span>
<a name="l00515"></a>00515 <span class="comment">//            int accumDim1 = accumToAnalze.GetLength(0);</span>
<a name="l00516"></a>00516 <span class="comment">//            int accumDim2 = accumToAnalze.GetLength(1);</span>
<a name="l00517"></a>00517 
<a name="l00518"></a>00518 <span class="comment">//            // Run through to find cell with most votes</span>
<a name="l00519"></a>00519 <span class="comment">//            for (int s = 0; s &lt; accumDim1; s++)</span>
<a name="l00520"></a>00520 <span class="comment">//            {</span>
<a name="l00521"></a>00521 <span class="comment">//                for (int t = 0; t &lt; accumDim2; t++)</span>
<a name="l00522"></a>00522 <span class="comment">//                {</span>
<a name="l00523"></a>00523 <span class="comment">//                    if (accumToAnalze[s, t] &gt; maxAccum)</span>
<a name="l00524"></a>00524 <span class="comment">//                    {</span>
<a name="l00525"></a>00525 <span class="comment">//                        maxTheta = s;</span>
<a name="l00526"></a>00526 <span class="comment">//                        maxRho = t;</span>
<a name="l00527"></a>00527 <span class="comment">//                        maxAccum = accumToAnalze[s, t];</span>
<a name="l00528"></a>00528 <span class="comment">//                    }</span>
<a name="l00529"></a>00529 <span class="comment">//                }</span>
<a name="l00530"></a>00530 <span class="comment">//            }</span>
<a name="l00531"></a>00531 
<a name="l00532"></a>00532 <span class="comment">//            maxTheta *= thetaIncrement; // Scale the Theta back to real size.</span>
<a name="l00533"></a>00533 <span class="comment">//            maxRho = maxRho * RhoIncrement; // Scale the Rho back to real size.</span>
<a name="l00534"></a>00534 <span class="comment">//            double x1 = (int)(maxRho * Math.Cos(MathHelper.ToRadians(maxTheta))); // Find the x Point corresponding the theta, rho</span>
<a name="l00535"></a>00535 <span class="comment">//            double y1 = (int)(maxRho * Math.Sin(MathHelper.ToRadians(maxTheta))); // Find the y Point corresponding the theta, rho</span>
<a name="l00536"></a>00536 
<a name="l00537"></a>00537 <span class="comment">//            double slope1 = 1;</span>
<a name="l00538"></a>00538 <span class="comment">//            int yintercept1 = 0;</span>
<a name="l00539"></a>00539 
<a name="l00540"></a>00540 <span class="comment">//            if (maxTheta != 270 &amp;&amp; maxTheta != 90)</span>
<a name="l00541"></a>00541 <span class="comment">//            {</span>
<a name="l00542"></a>00542 <span class="comment">//                slope1 = -1 / Math.Tan(MathHelper.ToRadians(maxTheta)); // Calculating the slope</span>
<a name="l00543"></a>00543 <span class="comment">//            }</span>
<a name="l00544"></a>00544 
<a name="l00545"></a>00545 <span class="comment">//            slope1 = Math.Round(slope1, 2);</span>
<a name="l00546"></a>00546 <span class="comment">//            yintercept1 = (int)(y1 - (slope1 * x1));</span>
<a name="l00547"></a>00547 
<a name="l00548"></a>00548 <span class="comment">//            // Store the information found about the line in the &#39;this.houghInfo&#39; array starting at the value &#39;StartIndexOfStoringHoughInfoList&#39;</span>
<a name="l00549"></a>00549 <span class="comment">//            this.houghInfo[startIndexOfStoringHoughInfoList + 0] = slope1;</span>
<a name="l00550"></a>00550 <span class="comment">//            this.houghInfo[startIndexOfStoringHoughInfoList + 1] = yintercept1;</span>
<a name="l00551"></a>00551 <span class="comment">//            this.houghInfo[startIndexOfStoringHoughInfoList + 2] = maxRho;</span>
<a name="l00552"></a>00552 <span class="comment">//            this.houghInfo[startIndexOfStoringHoughInfoList + 3] = maxTheta;</span>
<a name="l00553"></a>00553 <span class="comment">//            this.houghInfo[startIndexOfStoringHoughInfoList + 4] = x1;</span>
<a name="l00554"></a>00554 <span class="comment">//            this.houghInfo[startIndexOfStoringHoughInfoList + 5] = y1;</span>
<a name="l00555"></a>00555 <span class="comment">//            this.houghInfo[startIndexOfStoringHoughInfoList + 6] = maxAccum;</span>
<a name="l00556"></a>00556 <span class="comment">//        }</span>
<a name="l00557"></a>00557 
<a name="l00558"></a>00558 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00559"></a>00559 <span class="comment">//        /// Part of the old Hough system. Finds the edge values on the screen of the lines based on the slope and yInt.</span>
<a name="l00560"></a>00560 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00561"></a>00561 <span class="comment">//        /// &lt;param name=&quot;slope1&quot;&gt;Slope of the line&lt;/param&gt;</span>
<a name="l00562"></a>00562 <span class="comment">//        /// &lt;param name=&quot;yintercept1&quot;&gt;YIntercept of the line&lt;/param&gt;</span>
<a name="l00563"></a>00563 <span class="comment">//        /// &lt;param name=&quot;startIndexforStorageArray&quot;&gt;Where to store the information in the storage array&lt;/param&gt;</span>
<a name="l00564"></a>00564 <span class="comment">//        private void CalculateStartandStopofLine(double slope1, short yintercept1, int startIndexforStorageArray)</span>
<a name="l00565"></a>00565 <span class="comment">//        {</span>
<a name="l00566"></a>00566 <span class="comment">//            int startX = 0; </span>
<a name="l00567"></a>00567 <span class="comment">//            int startY = 0; </span>
<a name="l00568"></a>00568 <span class="comment">//            int endX = 0; </span>
<a name="l00569"></a>00569 <span class="comment">//            int endY = 0;</span>
<a name="l00570"></a>00570 
<a name="l00571"></a>00571 <span class="comment">//            // Now switch all the y to -y for the start and end values</span>
<a name="l00572"></a>00572 <span class="comment">//            // Left Side</span>
<a name="l00573"></a>00573 <span class="comment">//            if (yintercept1 &gt;= 0)</span>
<a name="l00574"></a>00574 <span class="comment">//            {</span>
<a name="l00575"></a>00575 <span class="comment">//                startX = (int)(-yintercept1 / slope1);</span>
<a name="l00576"></a>00576 <span class="comment">//                startY = 0;</span>
<a name="l00577"></a>00577 <span class="comment">//            }</span>
<a name="l00578"></a>00578 
<a name="l00579"></a>00579 <span class="comment">//            if (yintercept1 &lt;= 0 &amp;&amp; yintercept1 &gt; -this.screenHeight)</span>
<a name="l00580"></a>00580 <span class="comment">//            {</span>
<a name="l00581"></a>00581 <span class="comment">//                startX = 0;</span>
<a name="l00582"></a>00582 <span class="comment">//                startY = -(int)yintercept1;</span>
<a name="l00583"></a>00583 <span class="comment">//            }</span>
<a name="l00584"></a>00584 
<a name="l00585"></a>00585 <span class="comment">//            if (yintercept1 &lt; -this.screenHeight)</span>
<a name="l00586"></a>00586 <span class="comment">//            {</span>
<a name="l00587"></a>00587 <span class="comment">//                startX = (int)((-this.screenHeight - yintercept1) / slope1);</span>
<a name="l00588"></a>00588 <span class="comment">//                startY = this.screenHeight;</span>
<a name="l00589"></a>00589 <span class="comment">//            }</span>
<a name="l00590"></a>00590 
<a name="l00591"></a>00591 <span class="comment">//            // Find the end cordinates of the line.</span>
<a name="l00592"></a>00592 <span class="comment">//            // Right Side          </span>
<a name="l00593"></a>00593 <span class="comment">//            int yright = (int)((slope1 * this.screenWidth) + yintercept1);</span>
<a name="l00594"></a>00594 <span class="comment">//            if (yright &gt; 0)</span>
<a name="l00595"></a>00595 <span class="comment">//            {</span>
<a name="l00596"></a>00596 <span class="comment">//                endX = (int)(-yintercept1 / slope1);</span>
<a name="l00597"></a>00597 <span class="comment">//                endY = 0;</span>
<a name="l00598"></a>00598 <span class="comment">//            }</span>
<a name="l00599"></a>00599 
<a name="l00600"></a>00600 <span class="comment">//            if (yright &lt; 0 &amp;&amp; yright &gt; -this.screenHeight)</span>
<a name="l00601"></a>00601 <span class="comment">//            {</span>
<a name="l00602"></a>00602 <span class="comment">//                endX = this.screenWidth;</span>
<a name="l00603"></a>00603 <span class="comment">//                endY = -yright;</span>
<a name="l00604"></a>00604 <span class="comment">//            }</span>
<a name="l00605"></a>00605 
<a name="l00606"></a>00606 <span class="comment">//            if (yright &lt; -this.screenHeight)</span>
<a name="l00607"></a>00607 <span class="comment">//            {</span>
<a name="l00608"></a>00608 <span class="comment">//                endX = (int)((-this.screenHeight - yintercept1) / slope1);</span>
<a name="l00609"></a>00609 <span class="comment">//                endY = this.screenHeight;</span>
<a name="l00610"></a>00610 <span class="comment">//            }</span>
<a name="l00611"></a>00611 
<a name="l00612"></a>00612 <span class="comment">//            // Store the Line information in the array &#39;houghLineStartandStopVectors&#39; starting at the value &#39;startIndexforStorageArray&#39;</span>
<a name="l00613"></a>00613 <span class="comment">//            this.houghLineStartandStopVectors[startIndexforStorageArray + 0] = new Vector3(startX, startY, 0);</span>
<a name="l00614"></a>00614 <span class="comment">//            this.houghLineStartandStopVectors[startIndexforStorageArray + 1] = new Vector3(endX, endY, 0);</span>
<a name="l00615"></a>00615 <span class="comment">//        }</span>
<a name="l00616"></a>00616 
<a name="l00617"></a>00617 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00618"></a>00618 <span class="comment">//        /// For each white pixel that might be part of a line, Find all the potiential lines going through it and store each vote for that line in the accumlator&#39;s bins.</span>
<a name="l00619"></a>00619 <span class="comment">//        /// Calls the methods to search through the accumlator to find the bins with the largest values. </span>
<a name="l00620"></a>00620 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00621"></a>00621 <span class="comment">//        /// &lt;param name=&quot;isLine&quot;&gt;The trueFalse array of pixels that might be part of a line. &lt;/param&gt;</span>
<a name="l00622"></a>00622 <span class="comment">//        private void Hough(bool[,] isLine)</span>
<a name="l00623"></a>00623 <span class="comment">//        {</span>
<a name="l00624"></a>00624 <span class="comment">//            // Find all possible lines through each point and put into array bin.</span>
<a name="l00625"></a>00625 <span class="comment">//            for (short x = this.count1E; x &lt; this.screenWidth; x += UpdateSquareDimForAnalysis)</span>
<a name="l00626"></a>00626 <span class="comment">//            {</span>
<a name="l00627"></a>00627 <span class="comment">//                for (short y = this.count2E; y &lt; this.screenHeight; y += UpdateSquareDimForAnalysis)</span>
<a name="l00628"></a>00628 <span class="comment">//                {</span>
<a name="l00629"></a>00629 <span class="comment">//                    if (isLine[x, y] == true)</span>
<a name="l00630"></a>00630 <span class="comment">//                    {</span>
<a name="l00631"></a>00631 <span class="comment">//                        for (short theta = 0; theta &lt; 180; theta += ThetaIncrement)</span>
<a name="l00632"></a>00632 <span class="comment">//                        {</span>
<a name="l00633"></a>00633 <span class="comment">//                            // Bottom center = origin. </span>
<a name="l00634"></a>00634 <span class="comment">//                            short xprime = (short)(x - (this.screenWidth / 2));</span>
<a name="l00635"></a>00635 <span class="comment">//                            short yprime = (short)(-y + this.screenHeight);</span>
<a name="l00636"></a>00636 <span class="comment">//                            short rhoprime = (short)(((xprime * Math.Cos(MathHelper.ToRadians(theta))) + (yprime * Math.Sin(MathHelper.ToRadians(theta)))) / RhoIncrement);</span>
<a name="l00637"></a>00637 <span class="comment">//                            if (rhoprime &gt;= 0)</span>
<a name="l00638"></a>00638 <span class="comment">//                            {</span>
<a name="l00639"></a>00639 <span class="comment">//                                this.accum2[theta / ThetaIncrement, rhoprime]++;</span>
<a name="l00640"></a>00640 <span class="comment">//                            }</span>
<a name="l00641"></a>00641 <span class="comment">//                            else</span>
<a name="l00642"></a>00642 <span class="comment">//                            {</span>
<a name="l00643"></a>00643 <span class="comment">//                                this.accum2[theta / ThetaIncrement, -rhoprime]++;</span>
<a name="l00644"></a>00644 <span class="comment">//                            }</span>
<a name="l00645"></a>00645 <span class="comment">//                        }</span>
<a name="l00646"></a>00646 <span class="comment">//                    }</span>
<a name="l00647"></a>00647 <span class="comment">//                }</span>
<a name="l00648"></a>00648 <span class="comment">//            }</span>
<a name="l00649"></a>00649 
<a name="l00650"></a>00650 <span class="comment">//            this.count1E++;</span>
<a name="l00651"></a>00651 <span class="comment">//            if (this.count1E == UpdateSquareDimForAnalysis)</span>
<a name="l00652"></a>00652 <span class="comment">//            {</span>
<a name="l00653"></a>00653 <span class="comment">//                this.count1E = 0;</span>
<a name="l00654"></a>00654 <span class="comment">//                this.count2E++;</span>
<a name="l00655"></a>00655 <span class="comment">//                if (this.count2E == UpdateSquareDimForAnalysis)</span>
<a name="l00656"></a>00656 <span class="comment">//                {</span>
<a name="l00657"></a>00657 <span class="comment">//                    // Find the largest values. </span>
<a name="l00658"></a>00658 <span class="comment">//                    for (int i = 0; i &lt; NumberofLinesToFind; i++)</span>
<a name="l00659"></a>00659 <span class="comment">//                    {</span>
<a name="l00660"></a>00660 <span class="comment">//                        this.FindMaxInAccumArrayOfHough(this.accum2, ThetaIncrement, (short)(14 + (i * 7)));</span>
<a name="l00661"></a>00661 <span class="comment">//                        this.ClearMaxInAccum(this.accum2, ThetaIncrement, 14 + (i * 7));</span>
<a name="l00662"></a>00662 <span class="comment">//                    }</span>
<a name="l00663"></a>00663 
<a name="l00664"></a>00664 <span class="comment">//                    this.FindAverages(); // Find the average rho and theta</span>
<a name="l00665"></a>00665 <span class="comment">//                    Array.Clear(this.accum2, 0, this.accum2.Length); // Clear the accumulator</span>
<a name="l00666"></a>00666 <span class="comment">//                    this.count2E = 0;</span>
<a name="l00667"></a>00667 <span class="comment">//                }</span>
<a name="l00668"></a>00668 <span class="comment">//            }</span>
<a name="l00669"></a>00669 <span class="comment">//        }</span>
<a name="l00670"></a>00670 
<a name="l00671"></a>00671 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00672"></a>00672 <span class="comment">//        /// Find the average theta values. Weigh them according to the rho value of each one. Make a turning desision based off the weighted thetas if turnBytheta is on. </span>
<a name="l00673"></a>00673 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00674"></a>00674 <span class="comment">//        private void FindAverages()</span>
<a name="l00675"></a>00675 <span class="comment">//        {</span>
<a name="l00676"></a>00676 <span class="comment">//            int thetaSum = 0;</span>
<a name="l00677"></a>00677 <span class="comment">//            int rhoSum = 0;</span>
<a name="l00678"></a>00678 <span class="comment">//            int count = 0;</span>
<a name="l00679"></a>00679 <span class="comment">//            int rho = -1;</span>
<a name="l00680"></a>00680 <span class="comment">//            int theta = -1;</span>
<a name="l00681"></a>00681 <span class="comment">//            int binSize = 0;</span>
<a name="l00682"></a>00682 <span class="comment">//            int turn = -1;</span>
<a name="l00683"></a>00683 
<a name="l00684"></a>00684 <span class="comment">//            for (int i = 0; i &lt; NumberofLinesToFind; i++)</span>
<a name="l00685"></a>00685 <span class="comment">//            {</span>
<a name="l00686"></a>00686 <span class="comment">//                // If the rho or theta are the same as the last one, then don&#39;t count it. </span>
<a name="l00687"></a>00687 <span class="comment">//                if (this.houghInfo[(14 + (i * 7) + 4)] != rho &amp;&amp; this.houghInfo[(14 + (i * 7) + 5)] != theta &amp;&amp; this.houghInfo[(14 + (i * 7) + 6)] * 1.5 &gt; binSize)</span>
<a name="l00688"></a>00688 <span class="comment">//                {</span>
<a name="l00689"></a>00689 <span class="comment">//                    rho = (int)this.houghInfo[(14 + (i * 7) + 2)]; // Sum the rhos</span>
<a name="l00690"></a>00690 <span class="comment">//                    theta = (int)this.houghInfo[(14 + (i * 7) + 3)]; // Sum the thetas</span>
<a name="l00691"></a>00691 <span class="comment">//                    binSize = (int)this.houghInfo[(14 + (i * 7) + 4)]; // Get bin size</span>
<a name="l00692"></a>00692 <span class="comment">//                    rhoSum += rho;</span>
<a name="l00693"></a>00693 <span class="comment">//                    thetaSum += theta;</span>
<a name="l00694"></a>00694 <span class="comment">//                    turn += (theta - 90) * (577 - rho) / 500;</span>
<a name="l00695"></a>00695 <span class="comment">//                    count++;</span>
<a name="l00696"></a>00696 <span class="comment">//                }</span>
<a name="l00697"></a>00697 <span class="comment">//            }</span>
<a name="l00698"></a>00698 
<a name="l00699"></a>00699 <span class="comment">//            int averageTheta = thetaSum / count;</span>
<a name="l00700"></a>00700 <span class="comment">//            this.houghInfo[(14 + (NumberofLinesToFind * 7))] = averageTheta; // Compute and store the averages</span>
<a name="l00701"></a>00701 <span class="comment">//            this.houghInfo[(14 + (NumberofLinesToFind * 7)) + 1] = rhoSum / count;</span>
<a name="l00702"></a>00702 <span class="comment">//            if (this.turnIndicatorisTheta == true)</span>
<a name="l00703"></a>00703 <span class="comment">//            {</span>
<a name="l00704"></a>00704 <span class="comment">//                this.turnIndication = turn / count;</span>
<a name="l00705"></a>00705 <span class="comment">//            }</span>
<a name="l00706"></a>00706 <span class="comment">//        }</span>
<a name="l00707"></a>00707 
<a name="l00708"></a>00708 <span class="comment">//        /// &lt;summary&gt;</span>
<a name="l00709"></a>00709 <span class="comment">//        /// Clears the array arround the maximum. Gets information about the line to clear around from the &#39;this.houghInfo&#39; array</span>
<a name="l00710"></a>00710 <span class="comment">//        /// &lt;/summary&gt;</span>
<a name="l00711"></a>00711 <span class="comment">//        /// &lt;param name=&quot;accumToChange&quot;&gt;The Accumulator to clear around&lt;/param&gt;</span>
<a name="l00712"></a>00712 <span class="comment">//        /// &lt;param name=&quot;degreeIncrement&quot;&gt;The theta quantitization&lt;/param&gt;</span>
<a name="l00713"></a>00713 <span class="comment">//        /// &lt;param name=&quot;indexOffset&quot;&gt;How far into the &#39;this.houghInfo&#39; array is the data for the line we want to clear around&lt;/param&gt;</span>
<a name="l00714"></a>00714 <span class="comment">//        /// &lt;returns&gt; The accumulator with the values around the max cleared.&lt;/returns&gt;</span>
<a name="l00715"></a>00715 <span class="comment">//        private short[,] ClearMaxInAccum(short[,] accumToChange, short degreeIncrement, int indexOffset)</span>
<a name="l00716"></a>00716 <span class="comment">//        {</span>
<a name="l00717"></a>00717 <span class="comment">//            int rho = (int)(this.houghInfo[indexOffset + 2] / RhoIncrement);</span>
<a name="l00718"></a>00718 <span class="comment">//            int theta = (int)this.houghInfo[indexOffset + 3] / ThetaIncrement;</span>
<a name="l00719"></a>00719 <span class="comment">//            int accumDim1 = accumToChange.GetLength(0); // Get the size accum Array</span>
<a name="l00720"></a>00720 <span class="comment">//            int accumDim2 = accumToChange.GetLength(1);</span>
<a name="l00721"></a>00721 
<a name="l00722"></a>00722 <span class="comment">//            // Clear the one with the most votes</span>
<a name="l00723"></a>00723 <span class="comment">//            for (int degree = -ClearArroundMaxDegree / ThetaIncrement; degree &lt; ClearArroundMaxDegree / ThetaIncrement; degree++)</span>
<a name="l00724"></a>00724 <span class="comment">//            {</span>
<a name="l00725"></a>00725 <span class="comment">//                for (int phi = -ClearArroundMaxRho / RhoIncrement; phi &lt; ClearArroundMaxRho / RhoIncrement; phi++)</span>
<a name="l00726"></a>00726 <span class="comment">//                {</span>
<a name="l00727"></a>00727 <span class="comment">//                    int thetaprime = (theta + degree) % accumDim1;</span>
<a name="l00728"></a>00728 <span class="comment">//                    int rhoprime = (rho + phi) % accumDim2;</span>
<a name="l00729"></a>00729 <span class="comment">//                    if (thetaprime &gt; 0 &amp;&amp; thetaprime &lt; accumDim1 &amp;&amp; rhoprime &gt; 0 &amp;&amp; rhoprime &lt; accumDim2)</span>
<a name="l00730"></a>00730 <span class="comment">//                    {</span>
<a name="l00731"></a>00731 <span class="comment">//                        accumToChange[thetaprime, rhoprime] = 0;</span>
<a name="l00732"></a>00732 <span class="comment">//                    }</span>
<a name="l00733"></a>00733 <span class="comment">//                }</span>
<a name="l00734"></a>00734 <span class="comment">//            }</span>
<a name="l00735"></a>00735 
<a name="l00736"></a>00736 <span class="comment">//            return accumToChange;</span>
<a name="l00737"></a>00737 <span class="comment">//        }       </span>
<a name="l00738"></a>00738 <span class="comment">//    }</span>
<a name="l00739"></a>00739 <span class="comment">//}</span>
</pre></div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="_image_analysis_8cs.html">ImageAnalysis.cs</a>      </li>
      <li class="footer">Generated on Mon Mar 28 2011 23:56:56 for Robot Simulation by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
